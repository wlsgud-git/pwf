{"ast":null,"code":"import * as r from \"react\";\nimport { u as k, r as j, a as W, b as X, c as w, d as Y, e as Z, f as A, g as K, h as ee, i as R, j as te, k as ne, m as se, G as ae, n as re, o as ce, p as N, q as oe, t as ie, v as G, w as Q, x as $, y as ue, l as E, z as de, A as le, B as F, C as fe, D as pe, E as be, F as me, H as Se, I as ge, J as ve, K as he, M as z, N as Me, O as ye, P as Pe, Q as ke, S as Te, T as Ee, U as we, V as Ae, W as H, X as Ce, Y as Oe, Z as Ie, _ as De, $ as Le, a0 as Re, a1 as Ne, a2 as Fe, a3 as Ve, a4 as _e, a5 as ze, a6 as Be, a7 as L, a8 as qe, a9 as Ue, aa as Je } from \"./contexts-BPNgUYT_.mjs\";\nimport { m as T } from \"./room-CDUkJ6U1.mjs\";\nimport { ConnectionState as C, LocalTrackPublication as xe, facingModeFromLocalTrack as We, Room as Ge, Track as v, createAudioAnalyser as V, ParticipantKind as B } from \"livekit-client\";\nconst Qe = e => {\n  const t = r.useRef(e);\n  return r.useEffect(() => {\n    t.current = e;\n  }), t;\n};\nfunction $e(e, t) {\n  const n = je(),\n    s = Qe(t);\n  return r.useLayoutEffect(() => {\n    let a = !1;\n    const c = e.current;\n    if (!c) return;\n    function o(u, i) {\n      a || s.current(u, i);\n    }\n    return n == null || n.subscribe(c, o), () => {\n      a = !0, n == null || n.unsubscribe(c, o);\n    };\n  }, [e.current, n, s]), n == null ? void 0 : n.observer;\n}\nfunction He() {\n  let e = !1,\n    t = [];\n  const n = /* @__PURE__ */new Map();\n  if (typeof window > \"u\") return;\n  const s = new ResizeObserver((a, c) => {\n    t = t.concat(a), e || window.requestAnimationFrame(() => {\n      const o = /* @__PURE__ */new Set();\n      for (let u = 0; u < t.length; u++) {\n        if (o.has(t[u].target)) continue;\n        o.add(t[u].target);\n        const i = n.get(t[u].target);\n        i == null || i.forEach(d => d(t[u], c));\n      }\n      t = [], e = !1;\n    }), e = !0;\n  });\n  return {\n    observer: s,\n    subscribe(a, c) {\n      s.observe(a);\n      const o = n.get(a) ?? [];\n      o.push(c), n.set(a, o);\n    },\n    unsubscribe(a, c) {\n      const o = n.get(a) ?? [];\n      if (o.length === 1) {\n        s.unobserve(a), n.delete(a);\n        return;\n      }\n      const u = o.indexOf(c);\n      u !== -1 && o.splice(u, 1), n.set(a, o);\n    }\n  };\n}\nlet D;\nconst je = () => D || (D = He()),\n  Xe = e => {\n    const [t, n] = r.useState({\n      width: 0,\n      height: 0\n    });\n    r.useLayoutEffect(() => {\n      if (e.current) {\n        const {\n          width: a,\n          height: c\n        } = e.current.getBoundingClientRect();\n        n({\n          width: a,\n          height: c\n        });\n      }\n    }, [e.current]);\n    const s = r.useCallback(a => n(a.contentRect), []);\n    return $e(e, s), t;\n  };\nfunction b(e, t, n = !0) {\n  const [s, a] = r.useState(t);\n  return r.useEffect(() => {\n    if (n && a(t), typeof window > \"u\" || !e) return;\n    const c = e.subscribe(a);\n    return () => c.unsubscribe();\n  }, [e, n]), s;\n}\nfunction vt(e) {\n  const t = c => typeof window < \"u\" ? window.matchMedia(c).matches : !1,\n    [n, s] = r.useState(t(e));\n  function a() {\n    s(t(e));\n  }\n  return r.useEffect(() => {\n    const c = window.matchMedia(e);\n    return a(), c.addListener ? c.addListener(a) : c.addEventListener(\"change\", a), () => {\n      c.removeListener ? c.removeListener(a) : c.removeEventListener(\"change\", a);\n    };\n  }, [e]), n;\n}\nfunction ht(e) {\n  const t = k(e),\n    n = r.useCallback(async () => {\n      await t.startAudio();\n    }, [t]),\n    s = r.useMemo(() => j(t), [t]),\n    {\n      canPlayAudio: a\n    } = b(s, {\n      canPlayAudio: t.canPlaybackAudio\n    });\n  return {\n    canPlayAudio: a,\n    startAudio: n\n  };\n}\nfunction Mt(e) {\n  const {\n    state: t,\n    dispatch: n\n  } = W().pin;\n  return {\n    buttonProps: r.useMemo(() => {\n      const {\n        className: a\n      } = X();\n      return T(e, {\n        className: a,\n        disabled: !(t != null && t.length),\n        onClick: () => {\n          n && n({\n            msg: \"clear_pin\"\n          });\n        }\n      });\n    }, [e, n, t])\n  };\n}\nfunction yt(e = {}) {\n  const t = w(e.participant),\n    {\n      className: n,\n      connectionQualityObserver: s\n    } = r.useMemo(() => Y(t), [t]),\n    a = b(s, t.connectionQuality);\n  return {\n    className: n,\n    quality: a\n  };\n}\nfunction O(e) {\n  const t = k(e),\n    n = r.useMemo(() => Z(t), [t]);\n  return b(n, t.state);\n}\nfunction Pt(e, t) {\n  const n = typeof e == \"function\" ? e : t,\n    s = typeof e == \"string\" ? e : void 0,\n    a = A(),\n    {\n      send: c,\n      messageObservable: o,\n      isSendingObservable: u\n    } = r.useMemo(() => K(a, s, n), [a, s, n]),\n    i = b(o, void 0),\n    d = b(u, !1);\n  return {\n    message: i,\n    send: c,\n    isSending: d\n  };\n}\nfunction kt(e) {\n  const t = A(),\n    n = O(t);\n  return {\n    buttonProps: r.useMemo(() => {\n      const {\n        className: a,\n        disconnect: c\n      } = ee(t);\n      return T(e, {\n        className: a,\n        onClick: () => c(e.stopTracks ?? !0),\n        disabled: n === C.Disconnected\n      });\n    }, [t, e, n])\n  };\n}\nfunction Ye(e) {\n  if (e.publication instanceof xe) {\n    const t = e.publication.track;\n    if (t) {\n      const {\n        facingMode: n\n      } = We(t);\n      return n;\n    }\n  }\n  return \"undefined\";\n}\nfunction Tt({\n  trackRef: e,\n  props: t\n}) {\n  const n = R(e),\n    s = te(),\n    {\n      className: a\n    } = r.useMemo(() => ne(), []),\n    c = r.useMemo(() => se(n, s == null ? void 0 : s.pin.state), [n, s == null ? void 0 : s.pin.state]);\n  return {\n    mergedProps: r.useMemo(() => T(t, {\n      className: a,\n      onClick: u => {\n        var i, d, f, l, p;\n        (i = t.onClick) == null || i.call(t, u), c ? (f = s == null ? void 0 : (d = s.pin).dispatch) == null || f.call(d, {\n          msg: \"clear_pin\"\n        }) : (p = s == null ? void 0 : (l = s.pin).dispatch) == null || p.call(l, {\n          msg: \"set_pin\",\n          trackReference: n\n        });\n      }\n    }), [t, a, n, c, s == null ? void 0 : s.pin]),\n    inFocus: c\n  };\n}\nfunction Et(e, t, n = {}) {\n  const s = n.gridLayouts ?? ae,\n    {\n      width: a,\n      height: c\n    } = Xe(e),\n    o = re(s, t, a, c);\n  return r.useEffect(() => {\n    e.current && o && (e.current.style.setProperty(\"--lk-col-count\", o == null ? void 0 : o.columns.toString()), e.current.style.setProperty(\"--lk-row-count\", o == null ? void 0 : o.rows.toString()));\n  }, [e, o]), {\n    layout: o,\n    containerWidth: a,\n    containerHeight: c\n  };\n}\nfunction q(e, t = {}) {\n  var u, i;\n  const n = typeof e == \"string\" ? t.participant : e.participant,\n    s = w(n),\n    a = typeof e == \"string\" ? {\n      participant: s,\n      source: e\n    } : e,\n    [c, o] = r.useState(!!((u = a.publication) != null && u.isMuted || (i = s.getTrackPublication(a.source)) != null && i.isMuted));\n  return r.useEffect(() => {\n    const d = ce(a).subscribe(o);\n    return () => d.unsubscribe();\n  }, [N(a)]), c;\n}\nfunction Ze(e) {\n  const t = w(e),\n    n = r.useMemo(() => oe(t), [t]);\n  return b(n, t.isSpeaking);\n}\nfunction Ke(e = {}) {\n  const t = k(e.room),\n    [n, s] = r.useState(t.localParticipant),\n    [a, c] = r.useState(n.isMicrophoneEnabled),\n    [o, u] = r.useState(n.isCameraEnabled),\n    [i, d] = r.useState(n.isScreenShareEnabled),\n    [f, l] = r.useState(n.lastMicrophoneError),\n    [p, S] = r.useState(n.lastCameraError),\n    [g, m] = r.useState(void 0),\n    [y, h] = r.useState(void 0),\n    P = M => {\n      u(M.isCameraEnabled), c(M.isMicrophoneEnabled), d(M.isScreenShareEnabled), h(M.cameraTrack), m(M.microphoneTrack), l(M.participant.lastMicrophoneError), S(M.participant.lastCameraError), s(M.participant);\n    };\n  return r.useEffect(() => {\n    const M = ie(t.localParticipant).subscribe(P);\n    return () => M.unsubscribe();\n  }, [t]), {\n    isMicrophoneEnabled: a,\n    isScreenShareEnabled: i,\n    isCameraEnabled: o,\n    microphoneTrack: g,\n    cameraTrack: y,\n    lastMicrophoneError: f,\n    lastCameraError: p,\n    localParticipant: n\n  };\n}\nfunction wt() {\n  const e = A(),\n    t = r.useMemo(() => G(e.localParticipant), [e]);\n  return b(t, e.localParticipant.permissions);\n}\nfunction At({\n  kind: e,\n  room: t,\n  track: n,\n  requestPermissions: s,\n  onError: a\n}) {\n  const c = Q(),\n    o = r.useMemo(() => t ?? c ?? new Ge(), [t, c]),\n    u = r.useMemo(() => $(e, a, s), [e, s, a]),\n    i = b(u, []),\n    [d, f] = r.useState((o == null ? void 0 : o.getActiveDevice(e)) ?? \"default\"),\n    {\n      className: l,\n      activeDeviceObservable: p,\n      setActiveMediaDevice: S\n    } = r.useMemo(() => ue(e, o), [e, o, n]);\n  return r.useEffect(() => {\n    const g = p.subscribe(m => {\n      m && (E.info(\"setCurrentDeviceId\", m), f(m));\n    });\n    return () => {\n      g == null || g.unsubscribe();\n    };\n  }, [p]), {\n    devices: i,\n    className: l,\n    activeDeviceId: d,\n    setActiveMediaDevice: S\n  };\n}\nfunction Ct({\n  kind: e,\n  onError: t\n}) {\n  const n = r.useMemo(() => $(e, t), [e, t]);\n  return b(n, []);\n}\nfunction et(e, t, n = {}) {\n  const s = r.useRef([]),\n    a = r.useRef(-1),\n    c = t !== a.current,\n    o = typeof n.customSortFunction == \"function\" ? n.customSortFunction(e) : de(e);\n  let u = [...o];\n  if (c === !1) try {\n    u = le(s.current, o, t);\n  } catch (i) {\n    E.error(\"Error while running updatePages(): \", i);\n  }\n  return c ? s.current = o : s.current = u, a.current = t, u;\n}\nfunction Ot(e, t) {\n  const [n, s] = r.useState(1),\n    a = Math.max(Math.ceil(t.length / e), 1);\n  n > a && s(a);\n  const c = n * e,\n    o = c - e,\n    u = l => {\n      s(p => l === \"next\" ? p === a ? p : p + 1 : p === 1 ? p : p - 1);\n    },\n    i = l => {\n      l > a ? s(a) : l < 1 ? s(1) : s(l);\n    },\n    f = et(t, e).slice(o, c);\n  return {\n    totalPageCount: a,\n    nextPage: () => u(\"next\"),\n    prevPage: () => u(\"previous\"),\n    setPage: i,\n    firstItemIndex: o,\n    lastItemIndex: c,\n    tracks: f,\n    currentPage: n\n  };\n}\nfunction It(e = {}) {\n  let t = F();\n  e.participant && (t = e.participant);\n  const n = r.useMemo(() => fe(t), [t]),\n    {\n      identity: s,\n      name: a,\n      metadata: c\n    } = b(n, {\n      name: t == null ? void 0 : t.name,\n      identity: t == null ? void 0 : t.identity,\n      metadata: t == null ? void 0 : t.metadata\n    });\n  return {\n    identity: s,\n    name: a,\n    metadata: c\n  };\n}\nfunction Dt(e = {}) {\n  const t = w(e.participant),\n    n = r.useMemo(() => G(t), [t]);\n  return b(n, t.permissions);\n}\nfunction Lt({\n  trackRef: e,\n  onParticipantClick: t,\n  disableSpeakingIndicator: n,\n  htmlProps: s\n}) {\n  const a = R(e),\n    c = r.useMemo(() => {\n      const {\n        className: p\n      } = pe();\n      return T(s, {\n        className: p,\n        onClick: S => {\n          var g;\n          if ((g = s.onClick) == null || g.call(s, S), typeof t == \"function\") {\n            const m = a.publication ?? a.participant.getTrackPublication(a.source);\n            t({\n              participant: a.participant,\n              track: m\n            });\n          }\n        }\n      });\n    }, [s, t, a.publication, a.source, a.participant]),\n    o = a.participant.getTrackPublication(v.Source.Microphone),\n    u = r.useMemo(() => ({\n      participant: a.participant,\n      source: v.Source.Microphone,\n      publication: o\n    }), [o, a.participant]),\n    i = q(a),\n    d = q(u),\n    f = Ze(a.participant),\n    l = Ye(a);\n  return {\n    elementProps: {\n      \"data-lk-audio-muted\": d,\n      \"data-lk-video-muted\": i,\n      \"data-lk-speaking\": n === !0 ? !1 : f,\n      \"data-lk-local-participant\": a.participant.isLocal,\n      \"data-lk-source\": a.source,\n      \"data-lk-facing-mode\": l,\n      ...c\n    }\n  };\n}\nfunction _(e = {}) {\n  const t = k(e.room),\n    [n, s] = r.useState([]);\n  return r.useEffect(() => {\n    const a = be(t, {\n      additionalRoomEvents: e.updateOnlyOn\n    }).subscribe(s);\n    return () => a.unsubscribe();\n  }, [t, JSON.stringify(e.updateOnlyOn)]), n;\n}\nfunction Rt(e = {}) {\n  const t = _(e),\n    {\n      localParticipant: n\n    } = Ke(e);\n  return r.useMemo(() => [n, ...t], [n, t]);\n}\nfunction Nt(e) {\n  return e = me(e), r.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);\n}\nfunction Ft(e, t = {}) {\n  const n = A(),\n    [s] = r.useState(t.updateOnlyOn),\n    a = r.useMemo(() => typeof e == \"string\" ? Se(n, e, {\n      additionalEvents: s\n    }) : ge(n, e, {\n      additionalEvents: s\n    }), [n, JSON.stringify(e), s]),\n    [c, o] = r.useState({\n      p: void 0\n    });\n  return r.useEffect(() => {\n    const u = a.subscribe(i => o({\n      p: i\n    }));\n    return () => u.unsubscribe();\n  }, [a]), c.p;\n}\nfunction Vt(e = {}) {\n  const t = k(e.room),\n    n = r.useMemo(() => ve(t), [t]),\n    {\n      name: s,\n      metadata: a\n    } = b(n, {\n      name: t.name,\n      metadata: t.metadata\n    });\n  return {\n    name: s,\n    metadata: a\n  };\n}\nfunction tt() {\n  const e = A(),\n    t = r.useMemo(() => he(e), [e]);\n  return b(t, e.activeSpeakers);\n}\nfunction _t(e) {\n  const [t, n] = r.useState(z(e)),\n    s = tt();\n  return r.useEffect(() => {\n    n(z(e));\n  }, [s, e]), t;\n}\nfunction zt({\n  room: e,\n  props: t\n}) {\n  const n = k(e),\n    {\n      className: s,\n      roomAudioPlaybackAllowedObservable: a,\n      handleStartAudioPlayback: c\n    } = r.useMemo(() => Me(), []),\n    o = r.useMemo(() => a(n), [n, a]),\n    {\n      canPlayAudio: u\n    } = b(o, {\n      canPlayAudio: n.canPlaybackAudio\n    });\n  return {\n    mergedProps: r.useMemo(() => T(t, {\n      className: s,\n      onClick: () => {\n        c(n);\n      },\n      style: {\n        display: u ? \"none\" : \"block\"\n      }\n    }), [t, s, u, c, n]),\n    canPlayAudio: u\n  };\n}\nfunction Bt({\n  room: e,\n  props: t\n}) {\n  const n = k(e),\n    {\n      className: s,\n      roomVideoPlaybackAllowedObservable: a,\n      handleStartVideoPlayback: c\n    } = r.useMemo(() => ye(), []),\n    o = r.useMemo(() => a(n), [n, a]),\n    {\n      canPlayVideo: u\n    } = b(o, {\n      canPlayVideo: n.canPlaybackVideo\n    });\n  return {\n    mergedProps: r.useMemo(() => T(t, {\n      className: s,\n      onClick: () => {\n        c(n);\n      },\n      style: {\n        display: u ? \"none\" : \"block\"\n      }\n    }), [t, s, u, c, n]),\n    canPlayVideo: u\n  };\n}\nfunction qt(e, t = {}) {\n  const n = r.useRef(null),\n    s = r.useRef(null),\n    a = t.minSwipeDistance ?? 50,\n    c = i => {\n      s.current = null, n.current = i.targetTouches[0].clientX;\n    },\n    o = i => {\n      s.current = i.targetTouches[0].clientX;\n    },\n    u = r.useCallback(() => {\n      if (!n.current || !s.current) return;\n      const i = n.current - s.current,\n        d = i > a,\n        f = i < -a;\n      d && t.onLeftSwipe && t.onLeftSwipe(), f && t.onRightSwipe && t.onRightSwipe();\n    }, [a, t]);\n  r.useEffect(() => {\n    const i = e.current;\n    return i && (i.addEventListener(\"touchstart\", c, {\n      passive: !0\n    }), i.addEventListener(\"touchmove\", o, {\n      passive: !0\n    }), i.addEventListener(\"touchend\", u, {\n      passive: !0\n    })), () => {\n      i && (i.removeEventListener(\"touchstart\", c), i.removeEventListener(\"touchmove\", o), i.removeEventListener(\"touchend\", u));\n    };\n  }, [e, u]);\n}\nfunction Ut({\n  props: e\n}) {\n  const {\n      dispatch: t,\n      state: n\n    } = W().widget,\n    {\n      className: s\n    } = r.useMemo(() => Pe(), []);\n  return {\n    mergedProps: r.useMemo(() => T(e, {\n      className: s,\n      onClick: () => {\n        t && t({\n          msg: \"toggle_chat\"\n        });\n      },\n      \"aria-pressed\": n != null && n.showChat ? \"true\" : \"false\",\n      \"data-lk-unread-msgs\": n ? n.unreadMessages < 10 ? n.unreadMessages.toFixed(0) : \"9+\" : \"0\"\n    }), [e, s, t, n])\n  };\n}\nfunction Jt(e, t, n = {}) {\n  const [s, a] = r.useState(void 0);\n  return r.useEffect(() => {\n    var o;\n    if (e === void 0) throw Error(\"token endpoint needs to be defined\");\n    if (((o = n.userInfo) == null ? void 0 : o.identity) === void 0) return;\n    (async () => {\n      E.debug(\"fetching token\");\n      const u = new URLSearchParams({\n          ...n.userInfo,\n          roomName: t\n        }),\n        i = await fetch(`${e}?${u.toString()}`);\n      if (!i.ok) {\n        E.error(`Could not fetch token. Server responded with status ${i.status}: ${i.statusText}`);\n        return;\n      }\n      const {\n        accessToken: d\n      } = await i.json();\n      a(d);\n    })();\n  }, [e, t, JSON.stringify(n)]), s;\n}\nfunction xt(e) {\n  var c, o;\n  const t = R(e),\n    {\n      className: n,\n      mediaMutedObserver: s\n    } = r.useMemo(() => ke(t), [N(t)]);\n  return {\n    isMuted: b(s, !!((c = t.publication) != null && c.isMuted || (o = t.participant.getTrackPublication(t.source)) != null && o.isMuted)),\n    className: n\n  };\n}\nfunction Wt({\n  source: e,\n  onChange: t,\n  initialState: n,\n  captureOptions: s,\n  publishOptions: a,\n  onDeviceError: c,\n  ...o\n}) {\n  var P;\n  const u = Q(),\n    i = (P = u == null ? void 0 : u.localParticipant) == null ? void 0 : P.getTrackPublication(e),\n    d = r.useRef(!1),\n    {\n      toggle: f,\n      className: l,\n      pendingObserver: p,\n      enabledObserver: S\n    } = r.useMemo(() => u ? Te(e, u, s, a, c) : Ee(), [u, e, JSON.stringify(s), a]),\n    g = b(p, !1),\n    m = b(S, n ?? !!(i != null && i.isEnabled));\n  r.useEffect(() => {\n    t == null || t(m, d.current), d.current = !1;\n  }, [m, t]), r.useEffect(() => {\n    n !== void 0 && (E.debug(\"forcing initial toggle state\", e, n), f(n));\n  }, []);\n  const y = r.useMemo(() => T(o, {\n      className: l\n    }), [o, l]),\n    h = r.useCallback(M => {\n      var I;\n      d.current = !0, f().catch(() => d.current = !1), (I = o.onClick) == null || I.call(o, M);\n    }, [o, f]);\n  return {\n    toggle: f,\n    enabled: m,\n    pending: g,\n    track: i,\n    buttonProps: {\n      ...y,\n      \"aria-pressed\": m,\n      \"data-lk-source\": e,\n      \"data-lk-enabled\": m,\n      disabled: g,\n      onClick: h\n    }\n  };\n}\nfunction Gt(e = [v.Source.Camera, v.Source.Microphone, v.Source.ScreenShare, v.Source.ScreenShareAudio, v.Source.Unknown], t = {}) {\n  const n = k(t.room),\n    [s, a] = r.useState([]),\n    [c, o] = r.useState([]),\n    u = r.useMemo(() => e.map(d => we(d) ? d.source : d), [JSON.stringify(e)]);\n  return r.useEffect(() => {\n    const d = Ae(n, u, {\n      additionalRoomEvents: t.updateOnlyOn,\n      onlySubscribed: t.onlySubscribed\n    }).subscribe(({\n      trackReferences: f,\n      participants: l\n    }) => {\n      E.debug(\"setting track bundles\", f, l), a(f), o(l);\n    });\n    return () => d.unsubscribe();\n  }, [n, JSON.stringify(t.onlySubscribed), JSON.stringify(t.updateOnlyOn), JSON.stringify(e)]), r.useMemo(() => {\n    if (H(e)) {\n      const d = st(e, c),\n        f = Array.from(s);\n      return c.forEach(l => {\n        d.has(l.identity) && (d.get(l.identity) ?? []).forEach(S => {\n          if (s.find(({\n            participant: m,\n            publication: y\n          }) => l.identity === m.identity && y.source === S)) return;\n          E.debug(`Add ${S} placeholder for participant ${l.identity}.`);\n          const g = {\n            participant: l,\n            source: S\n          };\n          f.push(g);\n        });\n      }), f;\n    } else return s;\n  }, [s, c, e]);\n}\nfunction nt(e, t) {\n  const n = new Set(e);\n  for (const s of t) n.delete(s);\n  return n;\n}\nfunction st(e, t) {\n  const n = /* @__PURE__ */new Map();\n  if (H(e)) {\n    const s = e.filter(a => a.withPlaceholder).map(a => a.source);\n    t.forEach(a => {\n      const c = a.getTrackPublications().map(u => {\n          var i;\n          return (i = u.track) == null ? void 0 : i.source;\n        }).filter(u => u !== void 0),\n        o = Array.from(nt(new Set(s), new Set(c)));\n      o.length > 0 && n.set(a.identity, o);\n    });\n  }\n  return n;\n}\nfunction at(e) {\n  const [t, n] = r.useState(Ce(e)),\n    {\n      trackObserver: s\n    } = r.useMemo(() => Oe(e), [e.participant.sid ?? e.participant.identity, e.source]);\n  return r.useEffect(() => {\n    const a = s.subscribe(c => {\n      n(c);\n    });\n    return () => a == null ? void 0 : a.unsubscribe();\n  }, [s]), {\n    participant: e.participant,\n    source: e.source ?? v.Source.Unknown,\n    publication: t\n  };\n}\nfunction Qt(e, t) {\n  const n = w(t);\n  return at({\n    name: e,\n    participant: n\n  });\n}\nfunction $t(e) {\n  const t = A(),\n    n = O(t),\n    s = r.useMemo(() => n === C.Disconnected, [n]),\n    a = r.useMemo(() => Ie(t, e), [t, e, s]),\n    c = b(a.isSendingObservable, !1),\n    o = b(a.messageObservable, []);\n  return {\n    send: a.send,\n    chatMessages: o,\n    isSending: c\n  };\n}\nfunction Ht(e = {}) {\n  const [t, n] = r.useState(De(e.defaults, e.preventLoad ?? !1)),\n    s = r.useCallback(i => {\n      n(d => ({\n        ...d,\n        audioEnabled: i\n      }));\n    }, []),\n    a = r.useCallback(i => {\n      n(d => ({\n        ...d,\n        videoEnabled: i\n      }));\n    }, []),\n    c = r.useCallback(i => {\n      n(d => ({\n        ...d,\n        audioDeviceId: i\n      }));\n    }, []),\n    o = r.useCallback(i => {\n      n(d => ({\n        ...d,\n        videoDeviceId: i\n      }));\n    }, []),\n    u = r.useCallback(i => {\n      n(d => ({\n        ...d,\n        username: i\n      }));\n    }, []);\n  return r.useEffect(() => {\n    Le(t, e.preventSave ?? !1);\n  }, [t, e.preventSave]), {\n    userChoices: t,\n    saveAudioInputEnabled: s,\n    saveVideoInputEnabled: a,\n    saveAudioInputDeviceId: c,\n    saveVideoInputDeviceId: o,\n    saveUsername: u\n  };\n}\nfunction jt(e, t = {}) {\n  const n = w(e),\n    s = k(t.room),\n    a = r.useMemo(() => Re(s, n), [s, n]);\n  return b(a, n.isLocal ? n.isE2EEEnabled : !!(n != null && n.isEncrypted));\n}\nfunction Xt(e, t = {\n  fftSize: 32,\n  smoothingTimeConstant: 0\n}) {\n  const n = Ne(e) ? e.publication.track : e,\n    [s, a] = r.useState(0);\n  return r.useEffect(() => {\n    if (!n || !n.mediaStream) return;\n    const {\n        cleanup: c,\n        analyser: o\n      } = V(n, t),\n      u = o.frequencyBinCount,\n      i = new Uint8Array(u),\n      f = setInterval(() => {\n        o.getByteFrequencyData(i);\n        let l = 0;\n        for (let p = 0; p < i.length; p++) {\n          const S = i[p];\n          l += S * S;\n        }\n        a(Math.sqrt(l / i.length) / 255);\n      }, 1e3 / 30);\n    return () => {\n      c(), clearInterval(f);\n    };\n  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]), s;\n}\nconst rt = e => {\n    const t = n => {\n      let c = 1 - Math.max(-100, Math.min(-10, n)) * -1 / 100;\n      return c = Math.sqrt(c), c;\n    };\n    return e.map(n => n === -1 / 0 ? 0 : t(n));\n  },\n  ct = {\n    bands: 5,\n    loPass: 100,\n    hiPass: 600,\n    updateInterval: 32,\n    analyserOptions: {\n      fftSize: 2048\n    }\n  };\nfunction Yt(e, t = {}) {\n  var o;\n  const n = e instanceof v ? e : (o = e == null ? void 0 : e.publication) == null ? void 0 : o.track,\n    s = {\n      ...ct,\n      ...t\n    },\n    [a, c] = r.useState(new Array(s.bands).fill(0));\n  return r.useEffect(() => {\n    if (!n || !(n != null && n.mediaStream)) return;\n    const {\n        analyser: u,\n        cleanup: i\n      } = V(n, s.analyserOptions),\n      d = u.frequencyBinCount,\n      f = new Float32Array(d),\n      p = setInterval(() => {\n        u.getFloatFrequencyData(f);\n        let S = new Float32Array(f.length);\n        for (let h = 0; h < f.length; h++) S[h] = f[h];\n        S = S.slice(t.loPass, t.hiPass);\n        const g = rt(S),\n          m = Math.ceil(g.length / s.bands),\n          y = [];\n        for (let h = 0; h < s.bands; h++) {\n          const P = g.slice(h * m, (h + 1) * m).reduce((M, I) => M += I, 0);\n          y.push(P / m);\n        }\n        c(y);\n      }, s.updateInterval);\n    return () => {\n      i(), clearInterval(p);\n    };\n  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]), a;\n}\nconst ot = {\n  barCount: 120,\n  volMultiplier: 5,\n  updateInterval: 20\n};\nfunction Zt(e, t = {}) {\n  var f;\n  const n = e instanceof v ? e : (f = e == null ? void 0 : e.publication) == null ? void 0 : f.track,\n    s = {\n      ...ot,\n      ...t\n    },\n    a = r.useRef(new Float32Array()),\n    c = r.useRef(performance.now()),\n    o = r.useRef(0),\n    [u, i] = r.useState([]),\n    d = r.useCallback(l => {\n      i(Array.from(ut(l, s.barCount).map(p => Math.sqrt(p) * s.volMultiplier)\n      // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\n      ));\n    }, []);\n  return r.useEffect(() => {\n    if (!n || !(n != null && n.mediaStream)) return;\n    const {\n        analyser: l,\n        cleanup: p\n      } = V(n, {\n        fftSize: U(s.barCount)\n      }),\n      S = U(s.barCount),\n      g = new Float32Array(S),\n      m = () => {\n        if (y = requestAnimationFrame(m), l.getFloatTimeDomainData(g), a.current.map((h, P) => h + g[P]), o.current += 1, performance.now() - c.current >= s.updateInterval) {\n          const h = g.map(P => P / o.current);\n          d(h), c.current = performance.now(), o.current = 0;\n        }\n      };\n    let y = requestAnimationFrame(m);\n    return () => {\n      p(), cancelAnimationFrame(y);\n    };\n  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t), d]), {\n    bars: u\n  };\n}\nfunction U(e) {\n  return e < 32 ? 32 : it(e);\n}\nfunction it(e) {\n  let t = 2;\n  for (; e >>= 1;) t <<= 1;\n  return t;\n}\nfunction ut(e, t) {\n  const n = Math.floor(e.length / t),\n    s = new Float32Array(t);\n  for (let a = 0; a < t; a++) {\n    const c = n * a;\n    let o = 0;\n    for (let u = 0; u < n; u++) o = o + Math.abs(e[c + u]);\n    s[a] = o / n;\n  }\n  return s;\n}\nfunction J(e, t) {\n  const n = F(),\n    s = _({\n      updateOnlyOn: []\n    }),\n    a = r.useMemo(() => t ? s.find(u => u.identity === t) : n, [t, s, n]),\n    c = r.useMemo(() => {\n      if (a) return Fe(a, {\n        sources: e\n      });\n    }, [a, JSON.stringify(e)]);\n  return b(c, []);\n}\nfunction dt(e) {\n  var n, s, a;\n  const t = r.useMemo(() => {\n    var c;\n    return (c = e == null ? void 0 : e.publication) != null && c.track ? Ve(e == null ? void 0 : e.publication.track) : void 0;\n  }, [(n = e == null ? void 0 : e.publication) == null ? void 0 : n.track]);\n  return b(t, {\n    timestamp: Date.now(),\n    rtpTimestamp: (a = (s = e == null ? void 0 : e.publication) == null ? void 0 : s.track) == null ? void 0 : a.rtpTimestamp\n  });\n}\nconst lt = {\n  bufferSize: 100\n  // maxAge: 2_000,\n};\nfunction ft(e, t) {\n  const n = {\n      ...lt,\n      ...t\n    },\n    [s, a] = r.useState([]),\n    c = dt(e),\n    o = u => {\n      var i;\n      (i = n.onTranscription) == null || i.call(n, u), a(d => ze(d,\n      // when first receiving a segment, add the current media timestamp to it\n      u.map(f => Be(f, c)), n.bufferSize));\n    };\n  return r.useEffect(() => {\n    if (!(e != null && e.publication)) return;\n    const u = _e(e.publication).subscribe(i => {\n      o(...i);\n    });\n    return () => {\n      u.unsubscribe();\n    };\n  }, [e && N(e), o]), {\n    segments: s\n  };\n}\nfunction pt(e = {}) {\n  const t = F(),\n    n = e.participant ?? t,\n    s = r.useMemo(\n    // weird typescript constraint\n    () => n ? L(n) : L(n), [n]);\n  return b(s, {\n    attributes: n == null ? void 0 : n.attributes\n  });\n}\nfunction Kt(e, t = {}) {\n  const n = w(t.participant),\n    [s, a] = r.useState(n.attributes[e]);\n  return r.useEffect(() => {\n    if (!n) return;\n    const c = L(n).subscribe(o => {\n      o.changed[e] !== void 0 && a(o.attributes[e]);\n    });\n    return () => {\n      c.unsubscribe();\n    };\n  }, [n, e]), s;\n}\nconst x = \"lk.agent.state\";\nfunction en() {\n  const e = _(),\n    t = e.find(l => l.kind === B.AGENT && !(\"lk.publish_on_behalf\" in l.attributes)),\n    n = e.find(l => l.kind === B.AGENT && l.attributes[\"lk.publish_on_behalf\"] === (t == null ? void 0 : t.identity)),\n    s = J([v.Source.Microphone, v.Source.Camera], t == null ? void 0 : t.identity),\n    a = J([v.Source.Microphone, v.Source.Camera], n == null ? void 0 : n.identity),\n    c = s.find(l => l.source === v.Source.Microphone) ?? a.find(l => l.source === v.Source.Microphone),\n    o = s.find(l => l.source === v.Source.Camera) ?? a.find(l => l.source === v.Source.Camera),\n    {\n      segments: u\n    } = ft(c),\n    i = O(),\n    {\n      attributes: d\n    } = pt({\n      participant: t\n    }),\n    f = r.useMemo(() => i === C.Disconnected ? \"disconnected\" : i === C.Connecting || !t || !(d != null && d[x]) ? \"connecting\" : d[x], [d, t, i]);\n  return {\n    agent: t,\n    state: f,\n    audioTrack: c,\n    videoTrack: o,\n    agentTranscriptions: u,\n    agentAttributes: d\n  };\n}\nfunction tn(e) {\n  const t = k(e),\n    n = O(t),\n    s = r.useMemo(() => qe(t), [t, n]);\n  return b(s, t.isRecording);\n}\nfunction bt(e) {\n  const t = A(),\n    s = O(t) === C.Disconnected,\n    a = r.useMemo(() => Ue(t, e), [t, e]);\n  return {\n    textStreams: b(s ? void 0 : a, [])\n  };\n}\nfunction nn(e) {\n  const {\n      participantIdentities: t,\n      trackSids: n\n    } = e ?? {},\n    {\n      textStreams: s\n    } = bt(Je.TRANSCRIPTION);\n  return r.useMemo(() => s.filter(c => t ? t.includes(c.participantInfo.identity) : !0).filter(c => {\n    var o;\n    return n ? n.includes(((o = c.streamInfo.attributes) == null ? void 0 : o[\"lk.transcribed_track_id\"]) ?? \"\") : !0;\n  }), [s, t, n]);\n}\nexport { wt as A, Nt as B, Ke as C, ht as D, Pt as E, Ye as F, q as G, Ze as H, It as I, Dt as J, Rt as K, Ft as L, _ as M, _t as N, tt as O, Jt as P, Qt as Q, Xt as R, Zt as S, J as T, ft as U, en as V, pt as W, Kt as X, tn as Y, bt as Z, nn as _, O as a, Ut as b, kt as c, Tt as d, At as e, zt as f, Bt as g, Wt as h, yt as i, b as j, xt as k, Lt as l, jt as m, Et as n, Ot as o, qt as p, Xe as q, et as r, Yt as s, Gt as t, Mt as u, Vt as v, $t as w, Ht as x, Ct as y, vt as z };","map":{"version":3,"names":["Qe","e","t","r","useRef","useEffect","current","$e","n","je","s","useLayoutEffect","a","c","o","u","i","subscribe","unsubscribe","observer","He","Map","window","ResizeObserver","concat","requestAnimationFrame","Set","length","has","target","add","get","forEach","d","observe","push","set","unobserve","delete","indexOf","splice","D","getResizeObserver","Xe","useState","width","height","getBoundingClientRect","useCallback","contentRect","b","vt","matchMedia","matches","addListener","addEventListener","removeListener","removeEventListener","ht","k","startAudio","useMemo","j","canPlayAudio","canPlaybackAudio","Mt","state","dispatch","W","pin","buttonProps","className","X","T","disabled","onClick","msg","yt","w","participant","connectionQualityObserver","Y","connectionQuality","quality","O","Z","Pt","A","send","messageObservable","isSendingObservable","K","message","isSending","kt","disconnect","ee","stopTracks","C","Disconnected","Ye","publication","xe","track","facingMode","We","Tt","trackRef","props","R","te","ne","se","mergedProps","call","f","p","l","trackReference","inFocus","Et","gridLayouts","ae","re","style","setProperty","columns","toString","rows","layout","containerWidth","containerHeight","q","source","isMuted","getTrackPublication","ce","N","Ze","oe","isSpeaking","Ke","room","localParticipant","isMicrophoneEnabled","isCameraEnabled","isScreenShareEnabled","lastMicrophoneError","S","lastCameraError","g","m","y","h","P","M","cameraTrack","microphoneTrack","ie","wt","G","permissions","At","kind","requestPermissions","onError","Q","Ge","$","getActiveDevice","activeDeviceObservable","setActiveMediaDevice","ue","E","info","devices","activeDeviceId","Ct","et","customSortFunction","de","le","error","Ot","Math","max","ceil","slice","totalPageCount","nextPage","prevPage","setPage","firstItemIndex","lastItemIndex","tracks","currentPage","It","F","fe","identity","name","metadata","Dt","Lt","onParticipantClick","disableSpeakingIndicator","htmlProps","pe","v","Source","Microphone","elementProps","isLocal","_","be","additionalRoomEvents","updateOnlyOn","JSON","stringify","Rt","Nt","me","Ft","Se","additionalEvents","ge","Vt","ve","tt","he","activeSpeakers","_t","z","zt","roomAudioPlaybackAllowedObservable","handleStartAudioPlayback","Me","display","Bt","roomVideoPlaybackAllowedObservable","handleStartVideoPlayback","ye","canPlayVideo","canPlaybackVideo","qt","minSwipeDistance","targetTouches","clientX","onLeftSwipe","onRightSwipe","passive","Ut","widget","Pe","showChat","unreadMessages","toFixed","Jt","Error","userInfo","debug","URLSearchParams","roomName","fetch","ok","status","statusText","accessToken","json","xt","mediaMutedObserver","ke","Wt","onChange","initialState","captureOptions","publishOptions","onDeviceError","toggle","pendingObserver","enabledObserver","Te","Ee","isEnabled","catch","I","enabled","pending","Gt","Camera","ScreenShare","ScreenShareAudio","Unknown","map","we","Ae","onlySubscribed","trackReferences","participants","H","st","Array","from","find","nt","filter","withPlaceholder","getTrackPublications","at","Ce","trackObserver","Oe","sid","Qt","$t","Ie","chatMessages","Ht","De","defaults","preventLoad","audioEnabled","videoEnabled","audioDeviceId","videoDeviceId","username","Le","preventSave","userChoices","saveAudioInputEnabled","saveVideoInputEnabled","saveAudioInputDeviceId","saveVideoInputDeviceId","saveUsername","jt","Re","isE2EEEnabled","isEncrypted","Xt","fftSize","smoothingTimeConstant","Ne","mediaStream","cleanup","analyser","V","frequencyBinCount","Uint8Array","setInterval","getByteFrequencyData","sqrt","clearInterval","rt","min","ct","bands","loPass","hiPass","updateInterval","analyserOptions","Yt","fill","Float32Array","getFloatFrequencyData","reduce","ot","barCount","volMultiplier","Zt","performance","now","ut","U","update","getFloatTimeDomainData","cancelAnimationFrame","bars","it","floor","abs","J","Fe","sources","dt","Ve","timestamp","Date","rtpTimestamp","lt","bufferSize","ft","onTranscription","ze","Be","_e","segments","pt","L","attributes","Kt","changed","x","en","B","AGENT","Connecting","agent","audioTrack","videoTrack","agentTranscriptions","agentAttributes","tn","qe","isRecording","bt","Ue","textStreams","nn","participantIdentities","trackSids","Je","TRANSCRIPTION","includes","participantInfo","streamInfo"],"sources":["C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\internal\\useResizeObserver.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\internal\\useObservableState.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\internal\\useMediaQuery.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useAudioPlayback.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useClearPinButton.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useConnectionQualityIndicator.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useConnectionStatus.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useDataChannel.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useDisconnectButton.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useFacingMode.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useFocusToggle.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useGridLayout.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useIsMuted.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useIsSpeaking.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useLocalParticipant.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useLocalParticipantPermissions.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useMediaDeviceSelect.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useMediaDevices.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useVisualStableUpdate.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\usePagination.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipantInfo.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipantPermissions.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipantTile.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useRemoteParticipants.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipants.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\usePinnedTracks.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useRemoteParticipant.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useRoomInfo.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useSpeakingParticipants.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useSortedParticipants.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useStartAudio.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useStartVideo.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useSwipe.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useChatToggle.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useToken.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackMutedIndicator.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackToggle.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useTracks.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackRefBySourceOrName.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackByName.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useChat.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\usePersistentUserChoices.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useIsEncrypted.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackVolume.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipantTracks.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackSyncTime.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useTrackTranscription.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useParticipantAttributes.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useVoiceAssistant.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useIsRecording.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useTextStream.ts","C:\\Users\\ashh1\\Desktop\\project\\PlayWithFriends\\client\\node_modules\\@livekit\\components-react\\src\\hooks\\useTranscriptions.ts"],"sourcesContent":["/* eslint-disable no-return-assign */\n/* eslint-disable no-underscore-dangle */\nimport * as React from 'react';\n\nconst useLatest = <T>(current: T) => {\n  const storedValue = React.useRef(current);\n  React.useEffect(() => {\n    storedValue.current = current;\n  });\n  return storedValue;\n};\n\n/**\n * A React hook that fires a callback whenever ResizeObserver detects a change to its size\n * code extracted from https://github.com/jaredLunde/react-hook/blob/master/packages/resize-observer/src/index.tsx in order to not include the polyfill for resize-observer\n *\n * @internal\n */\nexport function useResizeObserver<T extends HTMLElement>(\n  target: React.RefObject<T>,\n  callback: UseResizeObserverCallback,\n) {\n  const resizeObserver = getResizeObserver();\n  const storedCallback = useLatest(callback);\n\n  React.useLayoutEffect(() => {\n    let didUnsubscribe = false;\n\n    const targetEl = target.current;\n    if (!targetEl) return;\n\n    function cb(entry: ResizeObserverEntry, observer: ResizeObserver) {\n      if (didUnsubscribe) return;\n      storedCallback.current(entry, observer);\n    }\n\n    resizeObserver?.subscribe(targetEl as HTMLElement, cb);\n\n    return () => {\n      didUnsubscribe = true;\n      resizeObserver?.unsubscribe(targetEl as HTMLElement, cb);\n    };\n  }, [target.current, resizeObserver, storedCallback]);\n\n  return resizeObserver?.observer;\n}\n\nfunction createResizeObserver() {\n  let ticking = false;\n  let allEntries: ResizeObserverEntry[] = [];\n\n  const callbacks: Map<unknown, Array<UseResizeObserverCallback>> = new Map();\n\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const observer = new ResizeObserver((entries: ResizeObserverEntry[], obs: ResizeObserver) => {\n    allEntries = allEntries.concat(entries);\n    if (!ticking) {\n      window.requestAnimationFrame(() => {\n        const triggered = new Set<Element>();\n        for (let i = 0; i < allEntries.length; i++) {\n          if (triggered.has(allEntries[i].target)) continue;\n          triggered.add(allEntries[i].target);\n          const cbs = callbacks.get(allEntries[i].target);\n          cbs?.forEach((cb) => cb(allEntries[i], obs));\n        }\n        allEntries = [];\n        ticking = false;\n      });\n    }\n    ticking = true;\n  });\n\n  return {\n    observer,\n    subscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      observer.observe(target);\n      const cbs = callbacks.get(target) ?? [];\n      cbs.push(callback);\n      callbacks.set(target, cbs);\n    },\n    unsubscribe(target: HTMLElement, callback: UseResizeObserverCallback) {\n      const cbs = callbacks.get(target) ?? [];\n      if (cbs.length === 1) {\n        observer.unobserve(target);\n        callbacks.delete(target);\n        return;\n      }\n      const cbIndex = cbs.indexOf(callback);\n      if (cbIndex !== -1) cbs.splice(cbIndex, 1);\n      callbacks.set(target, cbs);\n    },\n  };\n}\n\nlet _resizeObserver: ReturnType<typeof createResizeObserver>;\n\nconst getResizeObserver = () =>\n  !_resizeObserver ? (_resizeObserver = createResizeObserver()) : _resizeObserver;\n\nexport type UseResizeObserverCallback = (\n  entry: ResizeObserverEntry,\n  observer: ResizeObserver,\n) => unknown;\n\nexport const useSize = (target: React.RefObject<HTMLDivElement>) => {\n  const [size, setSize] = React.useState({ width: 0, height: 0 });\n  React.useLayoutEffect(() => {\n    if (target.current) {\n      const { width, height } = target.current.getBoundingClientRect();\n      setSize({ width, height });\n    }\n  }, [target.current]);\n\n  const resizeCallback = React.useCallback(\n    (entry: ResizeObserverEntry) => setSize(entry.contentRect),\n    [],\n  );\n  // Where the magic happens\n  useResizeObserver(target, resizeCallback);\n  return size;\n};\n","import * as React from 'react';\n// @ts-ignore\nimport type { Observable } from 'rxjs';\n\n/**\n * @internal\n */\nexport function useObservableState<T>(\n  observable: Observable<T> | undefined,\n  startWith: T,\n  resetWhenObservableChanges = true,\n) {\n  const [state, setState] = React.useState<T>(startWith);\n  React.useEffect(() => {\n    if (resetWhenObservableChanges) {\n      setState(startWith);\n    }\n    // observable state doesn't run in SSR\n    if (typeof window === 'undefined' || !observable) return;\n    const subscription = observable.subscribe(setState);\n    return () => subscription.unsubscribe();\n  }, [observable, resetWhenObservableChanges]);\n  return state;\n}\n","import * as React from 'react';\n/**\n * Implementation used from https://github.com/juliencrn/usehooks-ts\n *\n * @internal\n */\nexport function useMediaQuery(query: string): boolean {\n  const getMatches = (query: string): boolean => {\n    // Prevents SSR issues\n    if (typeof window !== 'undefined') {\n      return window.matchMedia(query).matches;\n    }\n    return false;\n  };\n\n  const [matches, setMatches] = React.useState<boolean>(getMatches(query));\n\n  function handleChange() {\n    setMatches(getMatches(query));\n  }\n\n  React.useEffect(() => {\n    const matchMedia = window.matchMedia(query);\n\n    // Triggered at the first client-side load and if query changes\n    handleChange();\n\n    // Listen matchMedia\n    if (matchMedia.addListener) {\n      matchMedia.addListener(handleChange);\n    } else {\n      matchMedia.addEventListener('change', handleChange);\n    }\n\n    return () => {\n      if (matchMedia.removeListener) {\n        matchMedia.removeListener(handleChange);\n      } else {\n        matchMedia.removeEventListener('change', handleChange);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [query]);\n\n  return matches;\n}\n","import type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useObservableState } from './internal';\nimport { roomAudioPlaybackAllowedObservable } from '@livekit/components-core';\nimport { useEnsureRoom } from '../context';\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useAudioPlayback` hook returns an object with a boolean `canPlayAudio` flag that indicates whether audio\n * playback is allowed in the current context, as well as a `startAudio` function that can be called in a button\n * `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useAudioPlayback(room?: Room): {\n  canPlayAudio: boolean;\n  startAudio: () => Promise<void>;\n} {\n  const roomEnsured = useEnsureRoom(room);\n  const startAudio = React.useCallback(async () => {\n    await roomEnsured.startAudio();\n  }, [roomEnsured]);\n\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  return { canPlayAudio, startAudio };\n}\n","import { setupClearPinButton } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport type { ClearPinButtonProps } from '../components';\n\n/**\n * The `useClearPinButton` hook provides props for the {@link ClearPinButton}\n * or your custom implementation of it component. It adds the `onClick` handler\n * to signal the `LayoutContext` that the tile in focus should be cleared.\n * @public\n */\nexport function useClearPinButton(props: ClearPinButtonProps) {\n  const { state, dispatch } = useLayoutContext().pin;\n\n  const buttonProps = React.useMemo(() => {\n    const { className } = setupClearPinButton();\n    const mergedProps = mergeProps(props, {\n      className,\n      disabled: !state?.length,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'clear_pin' });\n      },\n    });\n    return mergedProps;\n  }, [props, dispatch, state]);\n\n  return { buttonProps };\n}\n","import { setupConnectionQualityIndicator } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface ConnectionQualityIndicatorOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useConnectionQualityIndicator` hook provides props for the `ConnectionQualityIndicator` or your custom implementation of it component.\n * @example\n * ```tsx\n * const { quality } = useConnectionQualityIndicator();\n * // or\n * const { quality } = useConnectionQualityIndicator({ participant });\n * ```\n * @public\n */\nexport function useConnectionQualityIndicator(options: ConnectionQualityIndicatorOptions = {}) {\n  const p = useEnsureParticipant(options.participant);\n\n  const { className, connectionQualityObserver } = React.useMemo(\n    () => setupConnectionQualityIndicator(p),\n    [p],\n  );\n\n  const quality = useObservableState(connectionQualityObserver, p.connectionQuality);\n\n  return { className, quality };\n}\n","import { connectionStateObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useConnectionState` hook allows you to simply implement your own `ConnectionState` component.\n *\n * @example\n * ```tsx\n * const connectionState = useConnectionState(room);\n * ```\n * @public\n */\nexport function useConnectionState(room?: Room) {\n  // passed room takes precedence, if not supplied get current room context\n  const r = useEnsureRoom(room);\n  const observable = React.useMemo(() => connectionStateObserver(r), [r]);\n  const connectionState = useObservableState(observable, r.state);\n  return connectionState;\n}\n","import type { ReceivedDataMessage } from '@livekit/components-core';\nimport { setupDataMessageHandler } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { DataPublishOptions } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\ntype UseDataChannelReturnType<T extends string | undefined = undefined> = {\n  isSending: boolean;\n  send: (payload: Uint8Array, options: DataPublishOptions) => Promise<void>;\n  message: ReceivedDataMessage<T> | undefined;\n};\n\n/**\n * The `useDataChannel` hook returns the ability to send and receive messages.\n * Pass an optional `topic` to narrow down which messages are returned in the messages array.\n *\n * @remarks\n * There is only one data channel. Passing a `topic` does not open a new data channel.\n * It is only used to filter out messages with no or a different `topic`.\n *\n * @example\n * ```tsx\n * // Send messages to all participants via the 'chat' topic.\n * const { message: latestMessage, send } = useDataChannel('chat', (msg) => console.log(\"message received\", msg));\n * ```\n *\n * @example\n * ```tsx\n * // Receive all messages (no topic filtering)\n * const { message: latestMessage, send } = useDataChannel((msg) => console.log(\"message received\", msg));\n * ```\n *\n * @public\n */\nexport function useDataChannel<T extends string>(\n  topic: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n): UseDataChannelReturnType<T>;\n\n/**\n * Overload for `useDataChannel` without a topic. See {@link (useDataChannel:1)} for information and usage examples.\n *\n * @public\n */\nexport function useDataChannel(\n  onMessage?: (msg: ReceivedDataMessage) => void,\n): UseDataChannelReturnType;\n/**\n * @internal\n */\nexport function useDataChannel<T extends string>(\n  topicOrCallback?: T | ((msg: ReceivedDataMessage) => void),\n  callback?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  const onMessage = typeof topicOrCallback === 'function' ? topicOrCallback : callback;\n\n  const topic = typeof topicOrCallback === 'string' ? topicOrCallback : undefined;\n  const room = useRoomContext();\n  const { send, messageObservable, isSendingObservable } = React.useMemo(\n    () => setupDataMessageHandler(room, topic, onMessage),\n    [room, topic, onMessage],\n  );\n\n  const message = useObservableState(messageObservable, undefined);\n  const isSending = useObservableState(isSendingObservable, false);\n\n  return {\n    message,\n    send,\n    isSending,\n  };\n}\n","import { setupDisconnectButton } from '@livekit/components-core';\nimport { ConnectionState } from 'livekit-client';\nimport * as React from 'react';\nimport type { DisconnectButtonProps } from '../components';\nimport { useRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useDisconnectButton` hook is used to implement the `DisconnectButton` or your\n * custom implementation of it. It adds onClick handler to the button to disconnect\n * from the room.\n *\n * @example\n * ```tsx\n * const { buttonProps } = useDisconnectButton(buttonProps);\n * return <button {...buttonProps}>Disconnect</button>;\n * ```\n * @public\n */\nexport function useDisconnectButton(props: DisconnectButtonProps) {\n  const room = useRoomContext();\n  const connectionState = useConnectionState(room);\n\n  const buttonProps = React.useMemo(() => {\n    const { className, disconnect } = setupDisconnectButton(room);\n    const mergedProps = mergeProps(props, {\n      className,\n      onClick: () => disconnect(props.stopTracks ?? true),\n      disabled: connectionState === ConnectionState.Disconnected,\n    });\n    return mergedProps;\n  }, [room, props, connectionState]);\n\n  return { buttonProps };\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { LocalTrackPublication, facingModeFromLocalTrack } from 'livekit-client';\n\n/**\n * Try to determine the `facingMode` of a local participant video track.\n * @remarks\n * Works only on local video tracks.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @alpha\n */\nexport function useFacingMode(\n  trackReference: TrackReferenceOrPlaceholder,\n): 'user' | 'environment' | 'left' | 'right' | 'undefined' {\n  if (trackReference.publication instanceof LocalTrackPublication) {\n    const localTrack = trackReference.publication.track;\n    if (localTrack) {\n      const { facingMode } = facingModeFromLocalTrack(localTrack);\n      return facingMode;\n    }\n  }\n  return 'undefined';\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupFocusToggle, isTrackReferencePinned } from '@livekit/components-core';\nimport { useEnsureTrackRef, useMaybeLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseFocusToggleProps {\n  trackRef?: TrackReferenceOrPlaceholder;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useFocusToggle` hook is used to implement the `FocusToggle` or your custom implementation of it.\n * The `TrackReferenceOrPlaceholder` is used to register a onClick handler and to identify the track to focus on.\n *\n * @example\n * ```tsx\n * const { mergedProps, inFocus } = useFocusToggle({ trackRef, props: yourButtonProps });\n * return <button {...mergedProps}>{inFocus ? 'Unfocus' : 'Focus'}</button>;\n * ```\n * @public\n */\nexport function useFocusToggle({ trackRef, props }: UseFocusToggleProps) {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const layoutContext = useMaybeLayoutContext();\n  const { className } = React.useMemo(() => setupFocusToggle(), []);\n\n  const inFocus: boolean = React.useMemo(() => {\n    return isTrackReferencePinned(trackReference, layoutContext?.pin.state);\n  }, [trackReference, layoutContext?.pin.state]);\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: (event: React.MouseEvent<HTMLButtonElement, MouseEvent>) => {\n          // Call user defined on click callbacks.\n          props.onClick?.(event);\n\n          // Set or clear focus based on current focus state.\n          if (inFocus) {\n            layoutContext?.pin.dispatch?.({\n              msg: 'clear_pin',\n            });\n          } else {\n            layoutContext?.pin.dispatch?.({\n              msg: 'set_pin',\n              trackReference,\n            });\n          }\n        },\n      }),\n    [props, className, trackReference, inFocus, layoutContext?.pin],\n  );\n\n  return { mergedProps, inFocus };\n}\n","import { GRID_LAYOUTS, selectGridLayout } from '@livekit/components-core';\nimport type { GridLayoutDefinition, GridLayoutInfo } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useSize } from './internal';\n\n/**\n * The `useGridLayout` hook tries to select the best layout to fit all tiles.\n * If the available screen space is not enough, it will reduce the number of maximum visible\n * tiles and select a layout that still works visually within the given limitations.\n * As the order of tiles changes over time, the hook tries to keep visual updates to a minimum\n * while trying to display important tiles such as speaking participants or screen shares.\n *\n * @example\n * ```tsx\n * const { layout } = useGridLayout(gridElement, trackCount);\n * ```\n * @public\n */\nexport function useGridLayout(\n  /** HTML element that contains the grid. */\n  gridElement: React.RefObject<HTMLDivElement>,\n  /** Count of tracks that should get layed out */\n  trackCount: number,\n  options: {\n    gridLayouts?: GridLayoutDefinition[];\n  } = {},\n): { layout: GridLayoutInfo; containerWidth: number; containerHeight: number } {\n  const gridLayouts = options.gridLayouts ?? GRID_LAYOUTS;\n  const { width, height } = useSize(gridElement);\n  const layout = selectGridLayout(gridLayouts, trackCount, width, height);\n\n  React.useEffect(() => {\n    if (gridElement.current && layout) {\n      gridElement.current.style.setProperty('--lk-col-count', layout?.columns.toString());\n      gridElement.current.style.setProperty('--lk-row-count', layout?.rows.toString());\n    }\n  }, [gridElement, layout]);\n\n  return {\n    layout,\n    containerWidth: width,\n    containerHeight: height,\n  };\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  getTrackReferenceId,\n  mutedObserver,\n} from '@livekit/components-core';\nimport type { Participant, Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\n\n/** @public */\nexport interface UseIsMutedOptions {\n  participant?: Participant;\n}\n\n/**\n * The `useIsMuted` hook is used to implement the `TrackMutedIndicator` or your custom implementation of it.\n * It returns a `boolean` that indicates if the track is muted or not.\n *\n * @example With a track reference\n * ```tsx\n * const isMuted = useIsMuted(track);\n * ```\n *\n * @example With a track source / participant\n * ```tsx\n * const isMuted = useIsMuted('camera', { participant });\n * ```\n *\n * @param sourceOrTrackRef - Either a `TrackReference` or a `Track.Source` (see usage examples)\n * @param options - Additional options when using a `Track.Source`\n * @returns boolean indicating if the track is muted\n *\n * @public\n */\nexport function useIsMuted(trackRef: TrackReferenceOrPlaceholder): boolean;\nexport function useIsMuted(\n  sourceOrTrackRef: TrackReferenceOrPlaceholder | Track.Source,\n  options: UseIsMutedOptions = {},\n) {\n  const passedParticipant =\n    typeof sourceOrTrackRef === 'string' ? options.participant : sourceOrTrackRef.participant;\n  const p = useEnsureParticipant(passedParticipant);\n  const ref =\n    typeof sourceOrTrackRef === 'string'\n      ? { participant: p, source: sourceOrTrackRef }\n      : sourceOrTrackRef;\n  const [isMuted, setIsMuted] = React.useState(\n    !!(ref.publication?.isMuted || p.getTrackPublication(ref.source)?.isMuted),\n  );\n\n  React.useEffect(() => {\n    const listener = mutedObserver(ref).subscribe(setIsMuted);\n    return () => listener.unsubscribe();\n  }, [getTrackReferenceId(ref)]);\n\n  return isMuted;\n}\n","import { createIsSpeakingObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useIsSpeaking` hook returns a `boolean` that indicates if the participant is speaking or not.\n * @example\n * ```tsx\n * const isSpeaking = useIsSpeaking(participant);\n * ```\n * @public\n */\nexport function useIsSpeaking(participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  const observable = React.useMemo(() => createIsSpeakingObserver(p), [p]);\n  const isSpeaking = useObservableState(observable, p.isSpeaking);\n\n  return isSpeaking;\n}\n","import type { ParticipantMedia } from '@livekit/components-core';\nimport { observeParticipantMedia } from '@livekit/components-core';\nimport type { TrackPublication, LocalParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseLocalParticipantOptions {\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useLocalParticipant` hook returns the local participant and the associated state\n * around the participant.\n *\n * @example\n * ```tsx\n * const { localParticipant } = useLocalParticipant();\n * ```\n * @public\n */\nexport function useLocalParticipant(options: UseLocalParticipantOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [localParticipant, setLocalParticipant] = React.useState(room.localParticipant);\n\n  const [isMicrophoneEnabled, setIsMicrophoneEnabled] = React.useState(\n    localParticipant.isMicrophoneEnabled,\n  );\n  const [isCameraEnabled, setIsCameraEnabled] = React.useState(localParticipant.isCameraEnabled);\n  const [isScreenShareEnabled, setIsScreenShareEnabled] = React.useState(\n    localParticipant.isScreenShareEnabled,\n  );\n\n  const [lastMicrophoneError, setLastMicrophoneError] = React.useState(\n    localParticipant.lastMicrophoneError,\n  );\n  const [lastCameraError, setLastCameraError] = React.useState(localParticipant.lastCameraError);\n\n  const [microphoneTrack, setMicrophoneTrack] = React.useState<TrackPublication | undefined>(\n    undefined,\n  );\n  const [cameraTrack, setCameraTrack] = React.useState<TrackPublication | undefined>(undefined);\n\n  const handleUpdate = (media: ParticipantMedia<LocalParticipant>) => {\n    setIsCameraEnabled(media.isCameraEnabled);\n    setIsMicrophoneEnabled(media.isMicrophoneEnabled);\n    setIsScreenShareEnabled(media.isScreenShareEnabled);\n    setCameraTrack(media.cameraTrack);\n    setMicrophoneTrack(media.microphoneTrack);\n    setLastMicrophoneError(media.participant.lastMicrophoneError);\n    setLastCameraError(media.participant.lastCameraError);\n    setLocalParticipant(media.participant);\n  };\n  React.useEffect(() => {\n    const listener = observeParticipantMedia(room.localParticipant).subscribe(handleUpdate);\n    // TODO also listen to permission and metadata etc. events\n    return () => listener.unsubscribe();\n  }, [room]);\n\n  return {\n    isMicrophoneEnabled,\n    isScreenShareEnabled,\n    isCameraEnabled,\n    microphoneTrack,\n    cameraTrack,\n    lastMicrophoneError,\n    lastCameraError,\n    localParticipant,\n  };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useLocalParticipantPermissions` hook returns the local participant's permissions.\n *\n * @example\n * ```tsx\n * const { canPublish, canPublishData } = useLocalParticipantPermissions();\n * ```\n * @public\n */\nexport function useLocalParticipantPermissions(): ParticipantPermission | undefined {\n  const room = useRoomContext();\n  const permissionObserver = React.useMemo(\n    () => participantPermissionObserver(room.localParticipant),\n    [room],\n  );\n  const permissions = useObservableState(permissionObserver, room.localParticipant.permissions);\n  return permissions;\n}\n","import { createMediaDeviceObserver, setupDeviceSelector, log } from '@livekit/components-core';\nimport { Room, type LocalAudioTrack, type LocalVideoTrack } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseMediaDeviceSelectProps {\n  kind: MediaDeviceKind;\n  room?: Room;\n  track?: LocalAudioTrack | LocalVideoTrack;\n  /**\n   * this will call getUserMedia if the permissions are not yet given to enumerate the devices with device labels.\n   * in some browsers multiple calls to getUserMedia result in multiple permission prompts.\n   * It's generally advised only flip this to true, once a (preview) track has been acquired successfully with the\n   * appropriate permissions.\n   *\n   * @see {@link MediaDeviceMenu}\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices | MDN enumerateDevices}\n   */\n  requestPermissions?: boolean;\n  /**\n   * this callback gets called if an error is thrown when failing to select a device and also if a user\n   * denied permissions, eventhough the `requestPermissions` option is set to `true`.\n   * Most commonly this will emit a MediaDeviceError\n   */\n  onError?: (e: Error) => void;\n}\n\n/**\n * The `useMediaDeviceSelect` hook is used to implement the `MediaDeviceSelect` component and\n * returns o.a. the list of devices of a given kind (audioinput or videoinput), the currently active device\n * and a function to set the the active device.\n *\n * @example\n * ```tsx\n * const { devices, activeDeviceId, setActiveMediaDevice } = useMediaDeviceSelect({kind: 'audioinput'});\n * ```\n * @public\n */\nexport function useMediaDeviceSelect({\n  kind,\n  room,\n  track,\n  requestPermissions,\n  onError,\n}: UseMediaDeviceSelectProps) {\n  const roomContext = useMaybeRoomContext();\n\n  const roomFallback = React.useMemo(() => room ?? roomContext ?? new Room(), [room, roomContext]);\n\n  // List of all devices.\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError, requestPermissions),\n    [kind, requestPermissions, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  // Active device management.\n  const [currentDeviceId, setCurrentDeviceId] = React.useState<string>(\n    roomFallback?.getActiveDevice(kind) ?? 'default',\n  );\n  const { className, activeDeviceObservable, setActiveMediaDevice } = React.useMemo(\n    () => setupDeviceSelector(kind, roomFallback),\n    [kind, roomFallback, track],\n  );\n\n  React.useEffect(() => {\n    const listener = activeDeviceObservable.subscribe((deviceId) => {\n      if (!deviceId) {\n        return;\n      }\n      log.info('setCurrentDeviceId', deviceId);\n      setCurrentDeviceId(deviceId);\n    });\n    return () => {\n      listener?.unsubscribe();\n    };\n  }, [activeDeviceObservable]);\n\n  return { devices, className, activeDeviceId: currentDeviceId, setActiveMediaDevice };\n}\n","import * as React from 'react';\nimport { useObservableState } from './internal';\nimport { createMediaDeviceObserver } from '@livekit/components-core';\n\n/**\n * The `useMediaDevices` hook returns the list of media devices of a given kind.\n *\n * @example\n * ```tsx\n * const videoDevices = useMediaDevices({ kind: 'videoinput' });\n * const audioDevices = useMediaDevices({ kind: 'audioinput' });\n * ```\n * @public\n */\nexport function useMediaDevices({\n  kind,\n  onError,\n}: {\n  kind: MediaDeviceKind;\n  onError?: (e: Error) => void;\n}) {\n  const deviceObserver = React.useMemo(\n    () => createMediaDeviceObserver(kind, onError),\n    [kind, onError],\n  );\n  const devices = useObservableState(deviceObserver, [] as MediaDeviceInfo[]);\n  return devices;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { log, sortTrackReferences, updatePages } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseVisualStableUpdateOptions {\n  /** Overwrites the default sort function. */\n  customSortFunction?: (\n    trackReferences: TrackReferenceOrPlaceholder[],\n  ) => TrackReferenceOrPlaceholder[];\n}\n\n/**\n * The `useVisualStableUpdate` hook is used to prevent visually jarring jumps and shifts of elements\n * in an array. The algorithm only starts to update when there are more items than visually fit\n * on a page. If this is the case, it will make sure that speaking participants move to the first\n * page and are always visible.\n * @remarks\n * Updating the array can occur because attendees leave or join a room, or because they mute/unmute\n * or start speaking.\n * The hook is used for the `GridLayout` and `CarouselLayout` components.\n *\n * @example\n * ```tsx\n * const trackRefs = useTracks();\n * const updatedTrackRefs = useVisualStableUpdate(trackRefs, itemPerPage);\n * ```\n * @public\n */\nexport function useVisualStableUpdate(\n  /** `TrackReference`s to display in the grid.  */\n  trackReferences: TrackReferenceOrPlaceholder[],\n  maxItemsOnPage: number,\n  options: UseVisualStableUpdateOptions = {},\n): TrackReferenceOrPlaceholder[] {\n  const lastTrackRefs = React.useRef<TrackReferenceOrPlaceholder[]>([]);\n  const lastMaxItemsOnPage = React.useRef<number>(-1);\n  const layoutChanged = maxItemsOnPage !== lastMaxItemsOnPage.current;\n\n  const sortedTrackRefs =\n    typeof options.customSortFunction === 'function'\n      ? options.customSortFunction(trackReferences)\n      : sortTrackReferences(trackReferences);\n\n  let updatedTrackRefs: TrackReferenceOrPlaceholder[] = [...sortedTrackRefs];\n  if (layoutChanged === false) {\n    try {\n      updatedTrackRefs = updatePages(lastTrackRefs.current, sortedTrackRefs, maxItemsOnPage);\n    } catch (error) {\n      log.error('Error while running updatePages(): ', error);\n    }\n  }\n\n  // Save info for to compare against in the next update cycle.\n  if (layoutChanged) {\n    lastTrackRefs.current = sortedTrackRefs;\n  } else {\n    lastTrackRefs.current = updatedTrackRefs;\n  }\n  lastMaxItemsOnPage.current = maxItemsOnPage;\n\n  return updatedTrackRefs;\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useVisualStableUpdate } from './useVisualStableUpdate';\n\n/**\n * The `usePagination` hook implements simple pagination logic for use with arrays.\n * @example\n * ```tsx\n * const tracks = useTracks();\n * const pagination = usePagination(4, tracks);\n *\n * <TrackLoop tracks={pagination.tracks} />\n * ```\n * @alpha\n */\nexport function usePagination(itemPerPage: number, trackReferences: TrackReferenceOrPlaceholder[]) {\n  const [currentPage, setCurrentPage] = React.useState(1);\n  const totalPageCount = Math.max(Math.ceil(trackReferences.length / itemPerPage), 1);\n  if (currentPage > totalPageCount) {\n    setCurrentPage(totalPageCount);\n  }\n  const lastItemIndex = currentPage * itemPerPage;\n  const firstItemIndex = lastItemIndex - itemPerPage;\n\n  const changePage = (direction: 'next' | 'previous') => {\n    setCurrentPage((state) => {\n      if (direction === 'next') {\n        if (state === totalPageCount) {\n          return state;\n        }\n        return state + 1;\n      } else {\n        if (state === 1) {\n          return state;\n        }\n        return state - 1;\n      }\n    });\n  };\n\n  const goToPage = (num: number) => {\n    if (num > totalPageCount) {\n      setCurrentPage(totalPageCount);\n    } else if (num < 1) {\n      setCurrentPage(1);\n    } else {\n      setCurrentPage(num);\n    }\n  };\n\n  const updatedTrackReferences = useVisualStableUpdate(trackReferences, itemPerPage);\n\n  const tracksOnPage = updatedTrackReferences.slice(firstItemIndex, lastItemIndex);\n\n  return {\n    totalPageCount,\n    nextPage: () => changePage('next'),\n    prevPage: () => changePage('previous'),\n    setPage: goToPage,\n    firstItemIndex,\n    lastItemIndex,\n    tracks: tracksOnPage,\n    currentPage,\n  };\n}\n\nexport default usePagination;\n","import { participantInfoObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantInfo` hook returns the identity, name, and metadata of a given participant.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { identity, name, metadata } = useParticipantInfo({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantInfoOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantInfo(props: UseParticipantInfoOptions = {}) {\n  let p = useMaybeParticipantContext();\n  if (props.participant) {\n    p = props.participant;\n  }\n  const infoObserver = React.useMemo(() => participantInfoObserver(p), [p]);\n  const { identity, name, metadata } = useObservableState(infoObserver, {\n    name: p?.name,\n    identity: p?.identity,\n    metadata: p?.metadata,\n  });\n\n  return { identity, name, metadata };\n}\n","import { participantPermissionObserver } from '@livekit/components-core';\nimport type { ParticipantPermission } from '@livekit/protocol';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant } from '../context';\nimport { useObservableState } from './internal/useObservableState';\n\n/**\n * The `useParticipantPermissions` hook returns the permissions of a given participant.\n *\n * @example\n * ```tsx\n * const permissions = useParticipantPermissions({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantPermissionsOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantPermissions(\n  options: UseParticipantPermissionsOptions = {},\n): ParticipantPermission | undefined {\n  const p = useEnsureParticipant(options.participant);\n  const permissionObserver = React.useMemo(() => participantPermissionObserver(p), [p]);\n  const permissions = useObservableState(permissionObserver, p.permissions);\n  return permissions;\n}\n","import type { ParticipantClickEvent, TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport { setupParticipantTile } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureTrackRef } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useFacingMode } from './useFacingMode';\nimport { useIsMuted } from './useIsMuted';\nimport { useIsSpeaking } from './useIsSpeaking';\nimport { Track } from 'livekit-client';\n\n/** @public */\nexport interface UseParticipantTileProps<T extends HTMLElement> extends React.HTMLAttributes<T> {\n  /** The track reference to display. */\n  trackRef?: TrackReferenceOrPlaceholder;\n  disableSpeakingIndicator?: boolean;\n  onParticipantClick?: (event: ParticipantClickEvent) => void;\n  htmlProps: React.HTMLAttributes<T>;\n}\n\n/**\n * The `useParticipantTile` hook is used to implement the `ParticipantTile` and returns the props needed to render the tile.\n * @remarks\n * The returned props include many data attributes that are useful for CSS styling purposes because they\n * indicate the state of the participant and the track.\n * For example: `data-lk-audio-muted`, `data-lk-video-muted`, `data-lk-speaking`, `data-lk-local-participant`, `data-lk-source`, `data-lk-facing-mode`.\n * @public\n */\nexport function useParticipantTile<T extends HTMLElement>({\n  trackRef,\n  onParticipantClick,\n  disableSpeakingIndicator,\n  htmlProps,\n}: UseParticipantTileProps<T>) {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const mergedProps = React.useMemo(() => {\n    const { className } = setupParticipantTile();\n    return mergeProps(htmlProps, {\n      className,\n      onClick: (event: React.MouseEvent<T, MouseEvent>) => {\n        htmlProps.onClick?.(event);\n        if (typeof onParticipantClick === 'function') {\n          const track =\n            trackReference.publication ??\n            trackReference.participant.getTrackPublication(trackReference.source);\n          onParticipantClick({ participant: trackReference.participant, track });\n        }\n      },\n    });\n  }, [\n    htmlProps,\n    onParticipantClick,\n    trackReference.publication,\n    trackReference.source,\n    trackReference.participant,\n  ]);\n\n  const micTrack = trackReference.participant.getTrackPublication(Track.Source.Microphone);\n  const micRef = React.useMemo(() => {\n    return {\n      participant: trackReference.participant,\n      source: Track.Source.Microphone,\n      publication: micTrack,\n    };\n  }, [micTrack, trackReference.participant]);\n  const isVideoMuted = useIsMuted(trackReference);\n  const isAudioMuted = useIsMuted(micRef);\n  const isSpeaking = useIsSpeaking(trackReference.participant);\n  const facingMode = useFacingMode(trackReference);\n  return {\n    elementProps: {\n      'data-lk-audio-muted': isAudioMuted,\n      'data-lk-video-muted': isVideoMuted,\n      'data-lk-speaking': disableSpeakingIndicator === true ? false : isSpeaking,\n      'data-lk-local-participant': trackReference.participant.isLocal,\n      'data-lk-source': trackReference.source,\n      'data-lk-facing-mode': facingMode,\n      ...mergedProps,\n    } as React.HTMLAttributes<T>,\n  };\n}\n","import { connectedParticipantsObserver } from '@livekit/components-core';\nimport type { RoomEvent, RemoteParticipant, Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useRemoteParticipants` hook returns all remote participants (without the local) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useRemoteParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useRemoteParticipants(options: UseRemoteParticipantsOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const [participants, setParticipants] = React.useState<RemoteParticipant[]>([]);\n\n  React.useEffect(() => {\n    const listener = connectedParticipantsObserver(room, {\n      additionalRoomEvents: options.updateOnlyOn,\n    }).subscribe(setParticipants);\n    return () => listener.unsubscribe();\n  }, [room, JSON.stringify(options.updateOnlyOn)]);\n  return participants;\n}\n","import type { Room, RoomEvent } from 'livekit-client';\nimport { useLocalParticipant } from './useLocalParticipant';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseParticipantsOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what RoomEvents the hook updates.\n   * By default it updates on all relevant RoomEvents to keep the returned participants array up to date.\n   * The minimal set of non-overwriteable `RoomEvents` is: `[RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ConnectionStateChanged]`\n   */\n  updateOnlyOn?: RoomEvent[];\n  /**\n   * The room to use. If not provided, the hook will use the room from the context.\n   */\n  room?: Room;\n}\n\n/**\n * The `useParticipants` hook returns all participants (local and remote) of the current room.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `RoomEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participants = useParticipants();\n * <ParticipantLoop participants={participants}>\n *  <ParticipantName />\n * </ParticipantLoop>\n * ```\n * @public\n */\nexport function useParticipants(options: UseParticipantsOptions = {}) {\n  const remoteParticipants = useRemoteParticipants(options);\n  const { localParticipant } = useLocalParticipant(options);\n\n  return React.useMemo(\n    () => [localParticipant, ...remoteParticipants],\n    [localParticipant, remoteParticipants],\n  );\n}\n","import type { TrackReferenceOrPlaceholder } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { LayoutContextType } from '../context';\nimport { useEnsureLayoutContext } from '../context';\n\n/**\n * The `usePinnedTracks` hook returns a array of the pinned tracks of the current room.\n * @remarks\n * To function properly, this hook must be called within a `LayoutContext`.\n * @example\n * ```tsx\n * const pinnedTracks = usePinnedTracks();\n * ```\n * @public\n */\nexport function usePinnedTracks(layoutContext?: LayoutContextType): TrackReferenceOrPlaceholder[] {\n  layoutContext = useEnsureLayoutContext(layoutContext);\n  return React.useMemo(() => {\n    if (layoutContext?.pin.state !== undefined && layoutContext.pin.state.length >= 1) {\n      return layoutContext.pin.state;\n    }\n    return [];\n  }, [layoutContext.pin.state]);\n}\n","import {\n  type ParticipantIdentifier,\n  connectedParticipantObserver,\n  participantByIdentifierObserver,\n} from '@livekit/components-core';\nimport type { ParticipantEvent, RemoteParticipant } from 'livekit-client';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\n\n/** @public */\nexport interface UseRemoteParticipantOptions {\n  /**\n   * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n   * By default it updates on all relevant ParticipantEvents to keep the returned participant up to date.\n   */\n  updateOnlyOn?: ParticipantEvent[];\n}\n\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity and/or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant({kind: ParticipantKind.Agent, identity: 'myAgent'});\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identifier: ParticipantIdentifier,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\n/**\n * The `useRemoteParticipant` hook returns the first RemoteParticipant by either identity or based on the participant kind.\n * @remarks\n * To optimize performance, you can use the `updateOnlyOn` property to decide on what `ParticipantEvents` the hook updates.\n *\n * @example\n * ```tsx\n * const participant = useRemoteParticipant('Russ');\n * ```\n * @public\n */\nexport function useRemoteParticipant(\n  identity: string,\n  options?: UseRemoteParticipantOptions,\n): RemoteParticipant | undefined;\nexport function useRemoteParticipant(\n  identityOrIdentifier: string | ParticipantIdentifier,\n  options: UseRemoteParticipantOptions = {},\n): RemoteParticipant | undefined {\n  const room = useRoomContext();\n  const [updateOnlyOn] = React.useState(options.updateOnlyOn);\n\n  const observable = React.useMemo(() => {\n    if (typeof identityOrIdentifier === 'string') {\n      return connectedParticipantObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    } else {\n      return participantByIdentifierObserver(room, identityOrIdentifier, {\n        additionalEvents: updateOnlyOn,\n      });\n    }\n  }, [room, JSON.stringify(identityOrIdentifier), updateOnlyOn]);\n\n  // Using `wrapperParticipant` to ensure a new object reference,\n  // triggering a re-render when the participant events fire.\n  const [participantWrapper, setParticipantWrapper] = React.useState({\n    p: undefined as RemoteParticipant | undefined,\n  });\n  React.useEffect(() => {\n    const listener = observable.subscribe((p) => setParticipantWrapper({ p }));\n    return () => listener.unsubscribe();\n  }, [observable]);\n\n  return participantWrapper.p;\n}\n","import { roomInfoObserver } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useRoomInfo` hook returns the name and metadata of the given `Room`.\n * @remarks\n * Needs to be called inside a `RoomContext` or by passing a `Room` instance.\n *\n * @example\n * ```tsx\n * const { name, metadata } = useRoomInfo();\n * ```\n * @public\n */\nexport interface UseRoomInfoOptions {\n  room?: Room;\n}\n\n/** @public */\nexport function useRoomInfo(options: UseRoomInfoOptions = {}) {\n  const room = useEnsureRoom(options.room);\n  const infoObserver = React.useMemo(() => roomInfoObserver(room), [room]);\n  const { name, metadata } = useObservableState(infoObserver, {\n    name: room.name,\n    metadata: room.metadata,\n  });\n\n  return { name, metadata };\n}\n","import { activeSpeakerObserver } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useSpeakingParticipants` hook returns only the active speakers of all participants.\n *\n * @example\n * ```tsx\n * const activeSpeakers = useSpeakingParticipants();\n * ```\n * @public\n */\nexport function useSpeakingParticipants() {\n  const room = useRoomContext();\n  const speakerObserver = React.useMemo(() => activeSpeakerObserver(room), [room]);\n  const activeSpeakers = useObservableState(speakerObserver, room.activeSpeakers);\n  return activeSpeakers;\n}\n","import { sortParticipants } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useSpeakingParticipants } from './useSpeakingParticipants';\n\n/**\n * The `useSortedParticipants` hook returns the participants sorted by importance.\n * @public\n */\nexport function useSortedParticipants(participants: Array<Participant>) {\n  const [sortedParticipants, setSortedParticipants] = React.useState(\n    sortParticipants(participants),\n  );\n  const activeSpeakers = useSpeakingParticipants();\n\n  React.useEffect(() => {\n    setSortedParticipants(sortParticipants(participants));\n  }, [activeSpeakers, participants]);\n  return sortedParticipants;\n}\n","import { setupStartAudio } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartAudioProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In many browsers to start audio playback, the user must perform a user-initiated event such as clicking a button.\n * The `useStatAudio` hook returns an object with a boolean `canPlayAudio` flag\n * that indicates whether audio playback is allowed in the current context,\n * as well as a `startAudio` function that can be called in a button `onClick` callback to start audio playback in the current context.\n *\n * @see Autoplay policy on MDN web docs for more info: {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Best_practices#autoplay_policy}\n * @alpha\n */\nexport function useStartAudio({ room, props }: UseStartAudioProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback } = React.useMemo(\n    () => setupStartAudio(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomAudioPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomAudioPlaybackAllowedObservable],\n  );\n  const { canPlayAudio } = useObservableState(observable, {\n    canPlayAudio: roomEnsured.canPlaybackAudio,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartAudioPlayback(roomEnsured);\n        },\n        style: { display: canPlayAudio ? 'none' : 'block' },\n      }),\n    [props, className, canPlayAudio, handleStartAudioPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayAudio };\n}\n","import { setupStartVideo } from '@livekit/components-core';\nimport type { Room } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @alpha */\nexport interface UseStartVideoProps {\n  room?: Room;\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * In some browsers to start video playback in low power mode, the user must perform a user-initiated event such as clicking a button.\n * The `useStartVideo` hook returns an object with a boolean `canPlayVideo` flag\n * that indicates whether video playback is allowed in the current context,\n * as well as a `startVideo` function that can be called in a button `onClick` callback to start video playback in the current context.\n *\n * @alpha\n */\nexport function useStartVideo({ room, props }: UseStartVideoProps) {\n  const roomEnsured = useEnsureRoom(room);\n  const { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback } = React.useMemo(\n    () => setupStartVideo(),\n    [],\n  );\n  const observable = React.useMemo(\n    () => roomVideoPlaybackAllowedObservable(roomEnsured),\n    [roomEnsured, roomVideoPlaybackAllowedObservable],\n  );\n  const { canPlayVideo } = useObservableState(observable, {\n    canPlayVideo: roomEnsured.canPlaybackVideo,\n  });\n\n  const mergedProps = React.useMemo(\n    () =>\n      mergeProps(props, {\n        className,\n        onClick: () => {\n          handleStartVideoPlayback(roomEnsured);\n        },\n        style: { display: canPlayVideo ? 'none' : 'block' },\n      }),\n    [props, className, canPlayVideo, handleStartVideoPlayback, roomEnsured],\n  );\n\n  return { mergedProps, canPlayVideo };\n}\n","import * as React from 'react';\n\n/**\n * @alpha\n */\nexport type UseSwipeOptions = {\n  minSwipeDistance?: number;\n  onLeftSwipe?: () => void;\n  onRightSwipe?: () => void;\n};\n\n/**\n * Simple implementation to detect horizontal swipe actions.\n * Accepts callbacks for on right and left swipes.\n * @example\n * ```tsx\n *  <div\n      onTouchStart={onTouchStart}\n      onTouchMove={onTouchMove}\n      onTouchEnd={onTouchEnd}\n    >\n * ```\n * @alpha\n */\nexport function useSwipe(element: React.RefObject<HTMLElement>, options: UseSwipeOptions = {}) {\n  const touchStart = React.useRef<number | null>(null);\n  const touchEnd = React.useRef<number | null>(null);\n\n  // The required distance between touchStart and touchEnd to be detected as a swipe.\n  const minSwipeDistance = options.minSwipeDistance ?? 50;\n\n  const onTouchStart = (event: TouchEvent) => {\n    touchEnd.current = null; // Otherwise the swipe is fired even with usual touch events.\n    touchStart.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchMove = (event: TouchEvent) => {\n    touchEnd.current = event.targetTouches[0].clientX;\n  };\n\n  const onTouchEnd = React.useCallback(() => {\n    if (!touchStart.current || !touchEnd.current) {\n      return;\n    }\n    const distance = touchStart.current - touchEnd.current;\n    const isLeftSwipe = distance > minSwipeDistance;\n    const isRightSwipe = distance < -minSwipeDistance;\n\n    if (isLeftSwipe && options.onLeftSwipe) options.onLeftSwipe();\n    if (isRightSwipe && options.onRightSwipe) options.onRightSwipe();\n  }, [minSwipeDistance, options]);\n\n  React.useEffect(() => {\n    const elementCopy = element.current;\n    if (elementCopy) {\n      elementCopy.addEventListener('touchstart', onTouchStart, { passive: true });\n      elementCopy.addEventListener('touchmove', onTouchMove, { passive: true });\n      elementCopy.addEventListener('touchend', onTouchEnd, { passive: true });\n    }\n    return () => {\n      if (elementCopy) {\n        elementCopy.removeEventListener('touchstart', onTouchStart);\n        elementCopy.removeEventListener('touchmove', onTouchMove);\n        elementCopy.removeEventListener('touchend', onTouchEnd);\n      }\n    };\n  }, [element, onTouchEnd]);\n}\n","import { setupChatToggle } from '@livekit/components-core';\nimport { useLayoutContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport * as React from 'react';\n\n/** @public */\nexport interface UseChatToggleProps {\n  props: React.ButtonHTMLAttributes<HTMLButtonElement>;\n}\n\n/**\n * The `useChatToggle` hook provides state and functions for toggling the chat window.\n * @remarks\n * Depends on the `LayoutContext` to work properly.\n * @see {@link ChatToggle}, {@link Chat}\n * @public\n */\nexport function useChatToggle({ props }: UseChatToggleProps) {\n  const { dispatch, state } = useLayoutContext().widget;\n  const { className } = React.useMemo(() => setupChatToggle(), []);\n\n  const mergedProps = React.useMemo(() => {\n    return mergeProps(props, {\n      className,\n      onClick: () => {\n        if (dispatch) dispatch({ msg: 'toggle_chat' });\n      },\n      'aria-pressed': state?.showChat ? 'true' : 'false',\n      'data-lk-unread-msgs': state\n        ? state.unreadMessages < 10\n          ? state.unreadMessages.toFixed(0)\n          : '9+'\n        : '0',\n    });\n  }, [props, className, dispatch, state]);\n\n  return { mergedProps };\n}\n","import { log } from '@livekit/components-core';\nimport * as React from 'react';\n\n/** @public */\nexport interface UserInfo {\n  identity?: string;\n  name?: string;\n  metadata?: string;\n}\n\n/** @public */\nexport interface UseTokenOptions {\n  userInfo?: UserInfo;\n}\n\n/**\n * The `useToken` hook fetches a token from the given token endpoint with the given user info.\n *\n * @example\n * ```tsx\n * const token = useToken(<token-endpoint>, roomName, { userInfo: { identity, name }});\n * ```\n * @public */\nexport function useToken(\n  tokenEndpoint: string | undefined,\n  roomName: string,\n  options: UseTokenOptions = {},\n) {\n  const [token, setToken] = React.useState<string | undefined>(undefined);\n\n  React.useEffect(() => {\n    if (tokenEndpoint === undefined) {\n      throw Error('token endpoint needs to be defined');\n    }\n    if (options.userInfo?.identity === undefined) {\n      return;\n    }\n    const tokenFetcher = async () => {\n      log.debug('fetching token');\n      const params = new URLSearchParams({ ...options.userInfo, roomName });\n      const res = await fetch(`${tokenEndpoint}?${params.toString()}`);\n      if (!res.ok) {\n        log.error(\n          `Could not fetch token. Server responded with status ${res.status}: ${res.statusText}`,\n        );\n        return;\n      }\n      const { accessToken } = await res.json();\n      setToken(accessToken);\n    };\n    tokenFetcher();\n  }, [tokenEndpoint, roomName, JSON.stringify(options)]);\n  return token;\n}\n","import {\n  type TrackReferenceOrPlaceholder,\n  setupTrackMutedIndicator,\n  getTrackReferenceId,\n} from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureTrackRef } from '../context';\nimport { useObservableState } from './internal';\n\ninterface TrackMutedIndicatorReturnType {\n  isMuted: boolean;\n  className: string;\n}\n\n/**\n * The `useTrackMutedIndicator` hook is used to implement the `TrackMutedIndicator` component\n * and returns the muted state of the given track.\n *\n * @example\n * ```tsx\n * const { isMuted } = useTrackMutedIndicator(trackRef);\n * ```\n * @public\n */\nexport function useTrackMutedIndicator(\n  trackRef?: TrackReferenceOrPlaceholder,\n): TrackMutedIndicatorReturnType {\n  const trackReference = useEnsureTrackRef(trackRef);\n\n  const { className, mediaMutedObserver } = React.useMemo(\n    () => setupTrackMutedIndicator(trackReference),\n    [getTrackReferenceId(trackReference)],\n  );\n\n  const isMuted = useObservableState(\n    mediaMutedObserver,\n    !!(\n      trackReference.publication?.isMuted ||\n      trackReference.participant.getTrackPublication(trackReference.source)?.isMuted\n    ),\n  );\n\n  return { isMuted, className };\n}\n","import type { ToggleSource } from '@livekit/components-core';\nimport { setupMediaToggle, setupManualToggle, log } from '@livekit/components-core';\nimport * as React from 'react';\nimport type { TrackToggleProps } from '../components';\nimport { useMaybeRoomContext } from '../context';\nimport { mergeProps } from '../mergeProps';\nimport { useObservableState } from './internal';\n\n/** @public */\nexport interface UseTrackToggleProps<T extends ToggleSource>\n  extends Omit<TrackToggleProps<T>, 'showIcon'> {}\n\n/**\n * The `useTrackToggle` hook is used to implement the `TrackToggle` component and returns state\n * and functionality of the given track.\n *\n * @example\n * ```tsx\n * const { buttonProps, enabled } = useTrackToggle(trackRef);\n * return <button {...buttonProps}>{enabled ? 'disable' : 'enable'}</button>;\n * ```\n * @public\n */\nexport function useTrackToggle<T extends ToggleSource>({\n  source,\n  onChange,\n  initialState,\n  captureOptions,\n  publishOptions,\n  onDeviceError,\n  ...rest\n}: UseTrackToggleProps<T>) {\n  const room = useMaybeRoomContext();\n  const track = room?.localParticipant?.getTrackPublication(source);\n  /** `true` if a user interaction such as a click on the TrackToggle button has occurred. */\n  const userInteractionRef = React.useRef(false);\n\n  const { toggle, className, pendingObserver, enabledObserver } = React.useMemo(\n    () =>\n      room\n        ? setupMediaToggle<T>(source, room, captureOptions, publishOptions, onDeviceError)\n        : setupManualToggle(),\n    [room, source, JSON.stringify(captureOptions), publishOptions],\n  );\n\n  const pending = useObservableState(pendingObserver, false);\n  const enabled = useObservableState(enabledObserver, initialState ?? !!track?.isEnabled);\n\n  React.useEffect(() => {\n    onChange?.(enabled, userInteractionRef.current);\n    userInteractionRef.current = false;\n  }, [enabled, onChange]);\n\n  React.useEffect(() => {\n    if (initialState !== undefined) {\n      log.debug('forcing initial toggle state', source, initialState);\n      toggle(initialState);\n    }\n    // only execute once at the beginning\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const newProps = React.useMemo(() => mergeProps(rest, { className }), [rest, className]);\n\n  const clickHandler: React.MouseEventHandler<HTMLButtonElement> = React.useCallback(\n    (evt) => {\n      userInteractionRef.current = true;\n      toggle().catch(() => (userInteractionRef.current = false));\n      rest.onClick?.(evt);\n    },\n    [rest, toggle],\n  );\n\n  return {\n    toggle,\n    enabled,\n    pending,\n    track,\n    buttonProps: {\n      ...newProps,\n      'aria-pressed': enabled,\n      'data-lk-source': source,\n      'data-lk-enabled': enabled,\n      disabled: pending,\n      onClick: clickHandler,\n    } as React.ButtonHTMLAttributes<HTMLButtonElement>,\n  };\n}\n","import type {\n  SourcesArray,\n  TrackReference,\n  TrackReferenceOrPlaceholder,\n  TrackSourceWithOptions,\n  TrackReferencePlaceholder,\n} from '@livekit/components-core';\nimport {\n  isSourcesWithOptions,\n  isSourceWitOptions,\n  log,\n  trackReferencesObservable,\n} from '@livekit/components-core';\nimport type { Participant, Room, RoomEvent } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\n\n/** @public */\nexport type UseTracksOptions = {\n  updateOnlyOn?: RoomEvent[];\n  onlySubscribed?: boolean;\n  room?: Room;\n};\n\n/** @public */\nexport type UseTracksHookReturnType<T> = T extends Track.Source[]\n  ? TrackReference[]\n  : T extends TrackSourceWithOptions[]\n    ? TrackReferenceOrPlaceholder[]\n    : never;\n\n/**\n * The `useTracks` hook returns an array of `TrackReference` or `TrackReferenceOrPlaceholder` depending on the provided `sources` property.\n * If only subscribed tracks are desired, set the `onlySubscribed` property to `true`.\n * @example\n * ```ts\n * // Return all camera track publications.\n * const trackReferences: TrackReference[] = useTracks([Track.Source.Camera])\n * ```\n * @example\n * ```ts\n * // Return all subscribed camera tracks as well as placeholders for\n * // participants without a camera subscription.\n * const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] = useTracks([{source: Track.Source.Camera, withPlaceholder: true}])\n * ```\n * @public\n */\nexport function useTracks<T extends SourcesArray = Track.Source[]>(\n  sources: T = [\n    Track.Source.Camera,\n    Track.Source.Microphone,\n    Track.Source.ScreenShare,\n    Track.Source.ScreenShareAudio,\n    Track.Source.Unknown,\n  ] as T,\n  options: UseTracksOptions = {},\n): UseTracksHookReturnType<T> {\n  const room = useEnsureRoom(options.room);\n  const [trackReferences, setTrackReferences] = React.useState<TrackReference[]>([]);\n  const [participants, setParticipants] = React.useState<Participant[]>([]);\n\n  const sources_ = React.useMemo(() => {\n    return sources.map((s) => (isSourceWitOptions(s) ? s.source : s));\n  }, [JSON.stringify(sources)]);\n\n  React.useEffect(() => {\n    const subscription = trackReferencesObservable(room, sources_, {\n      additionalRoomEvents: options.updateOnlyOn,\n      onlySubscribed: options.onlySubscribed,\n    }).subscribe(({ trackReferences, participants }) => {\n      log.debug('setting track bundles', trackReferences, participants);\n      setTrackReferences(trackReferences);\n      setParticipants(participants);\n    });\n    return () => subscription.unsubscribe();\n  }, [\n    room,\n    JSON.stringify(options.onlySubscribed),\n    JSON.stringify(options.updateOnlyOn),\n    JSON.stringify(sources),\n  ]);\n\n  const maybeTrackReferences = React.useMemo(() => {\n    if (isSourcesWithOptions(sources)) {\n      const requirePlaceholder = requiredPlaceholders(sources, participants);\n      const trackReferencesWithPlaceholders: TrackReferenceOrPlaceholder[] =\n        Array.from(trackReferences);\n      participants.forEach((participant) => {\n        if (requirePlaceholder.has(participant.identity)) {\n          const sourcesToAddPlaceholder = requirePlaceholder.get(participant.identity) ?? [];\n          sourcesToAddPlaceholder.forEach((placeholderSource) => {\n            if (\n              trackReferences.find(\n                ({ participant: p, publication }) =>\n                  participant.identity === p.identity && publication.source === placeholderSource,\n              )\n            ) {\n              return;\n            }\n            log.debug(\n              `Add ${placeholderSource} placeholder for participant ${participant.identity}.`,\n            );\n            const placeholder: TrackReferencePlaceholder = {\n              participant,\n              source: placeholderSource,\n            };\n            trackReferencesWithPlaceholders.push(placeholder);\n          });\n        }\n      });\n      return trackReferencesWithPlaceholders;\n    } else {\n      return trackReferences;\n    }\n  }, [trackReferences, participants, sources]);\n\n  return maybeTrackReferences as UseTracksHookReturnType<T>;\n}\n\nfunction difference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\nexport function requiredPlaceholders<T extends SourcesArray>(\n  sources: T,\n  participants: Participant[],\n): Map<Participant['identity'], Track.Source[]> {\n  const placeholderMap = new Map<Participant['identity'], Track.Source[]>();\n  if (isSourcesWithOptions(sources)) {\n    const sourcesThatNeedPlaceholder = sources\n      .filter((sourceWithOption) => sourceWithOption.withPlaceholder)\n      .map((sourceWithOption) => sourceWithOption.source);\n\n    participants.forEach((participant) => {\n      const sourcesOfSubscribedTracks = participant\n        .getTrackPublications()\n        .map((pub) => pub.track?.source)\n        .filter((trackSource): trackSource is Track.Source => trackSource !== undefined);\n      const placeholderNeededForThisParticipant = Array.from(\n        difference(new Set(sourcesThatNeedPlaceholder), new Set(sourcesOfSubscribedTracks)),\n      );\n      // If the participant needs placeholder add it to the placeholder map.\n      if (placeholderNeededForThisParticipant.length > 0) {\n        placeholderMap.set(participant.identity, placeholderNeededForThisParticipant);\n      }\n    });\n  }\n  return placeholderMap;\n}\n","import type { TrackReferenceOrPlaceholder, TrackSource } from '@livekit/components-core';\nimport { setupMediaTrack, getTrackByIdentifier } from '@livekit/components-core';\nimport * as React from 'react';\nimport { Track } from 'livekit-client';\n\n/**\n * @internal\n */\nexport function useTrackRefBySourceOrName(\n  source: TrackSource<Track.Source>,\n): TrackReferenceOrPlaceholder {\n  const [publication, setPublication] = React.useState(getTrackByIdentifier(source));\n\n  const { trackObserver } = React.useMemo(() => {\n    return setupMediaTrack(source);\n  }, [source.participant.sid ?? source.participant.identity, source.source]);\n\n  React.useEffect(() => {\n    const subscription = trackObserver.subscribe((publication) => {\n      setPublication(publication);\n    });\n    return () => subscription?.unsubscribe();\n  }, [trackObserver]);\n\n  return {\n    participant: source.participant,\n    source: source.source ?? Track.Source.Unknown,\n    publication,\n  };\n}\n","import type { Participant } from 'livekit-client';\nimport { useEnsureParticipant } from '../context';\nimport { useTrackRefBySourceOrName } from './useTrackRefBySourceOrName';\n\n/**\n * This function `useTrackByName` allows you to access a track by referencing its track name.\n * Inside the function, it ensures that the a valid `participant` reference is available by checking\n * for both a passed participant argument and, if not available, a valid participant context.\n *\n * @public\n */\nexport function useTrackByName(name: string, participant?: Participant) {\n  const p = useEnsureParticipant(participant);\n  return useTrackRefBySourceOrName({ name, participant: p });\n}\n","import * as React from 'react';\nimport type { ChatOptions, ReceivedChatMessage } from '@livekit/components-core';\nimport { setupChat } from '@livekit/components-core';\nimport { ConnectionState } from 'livekit-client';\nimport { useRoomContext } from '../context';\nimport { useObservableState } from './internal/useObservableState';\nimport { useConnectionState } from './useConnectionStatus';\n\n/**\n * The `useChat` hook provides chat functionality for a LiveKit room.\n *\n * @remarks\n * Message history is not persisted and will be lost if the component is refreshed.\n * You may want to persist message history in the browser, a cache or a database.\n *\n * @returns An object containing:\n * - `chatMessages` - Array of received chat messages\n * - `send` - Function to send a new message\n * - `isSending` - Boolean indicating if a message is currently being sent\n *\n * @example\n * ```tsx\n * function ChatComponent() {\n *   const { chatMessages, send, isSending } = useChat();\n *\n *   return (\n *     <div>\n *       {chatMessages.map((msg) => (\n *         <div key={msg.timestamp}>\n *           {msg.from?.identity}: {msg.message}\n *         </div>\n *       ))}\n *       <button disabled={isSending} onClick={() => send(\"Hello!\")}>\n *         Send Message\n *       </button>\n *     </div>\n *   );\n * }\n * ```\n * @public\n */\nexport function useChat(options?: ChatOptions) {\n  const room = useRoomContext();\n  const connectionState = useConnectionState(room);\n  const isDisconnected = React.useMemo(\n    () => connectionState === ConnectionState.Disconnected,\n    [connectionState],\n  ); // used to reset the messages on room disconnect\n  const setup = React.useMemo<ReturnType<typeof setupChat>>(\n    () => setupChat(room, options),\n    [room, options, isDisconnected],\n  );\n  const isSending = useObservableState(setup.isSendingObservable, false);\n  const chatMessages = useObservableState<ReceivedChatMessage[]>(setup.messageObservable, []);\n\n  return { send: setup.send, chatMessages, isSending };\n}\n","import type { LocalUserChoices } from '@livekit/components-core';\nimport { loadUserChoices, saveUserChoices } from '@livekit/components-core';\nimport * as React from 'react';\n\n/**\n * Options for the `usePersistentDeviceSettings` hook.\n * @alpha\n */\nexport interface UsePersistentUserChoicesOptions {\n  /**\n   * The default value to use if reading from local storage returns no results or fails.\n   */\n  defaults?: Partial<LocalUserChoices>;\n  /**\n   * Whether to prevent saving to persistent storage.\n   * @defaultValue false\n   */\n  preventSave?: boolean;\n  /**\n   * Whether to prevent loading user choices from persistent storage and use `defaults` instead.\n   * @defaultValue false\n   */\n  preventLoad?: boolean;\n}\n\n/**\n * A hook that provides access to user choices stored in local storage, such as\n * selected media devices and their current state (on or off), as well as the user name.\n * @alpha\n */\nexport function usePersistentUserChoices(options: UsePersistentUserChoicesOptions = {}) {\n  const [userChoices, setSettings] = React.useState<LocalUserChoices>(\n    loadUserChoices(options.defaults, options.preventLoad ?? false),\n  );\n\n  const saveAudioInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, audioEnabled: isEnabled }));\n  }, []);\n  const saveVideoInputEnabled = React.useCallback((isEnabled: boolean) => {\n    setSettings((prev) => ({ ...prev, videoEnabled: isEnabled }));\n  }, []);\n  const saveAudioInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, audioDeviceId: deviceId }));\n  }, []);\n  const saveVideoInputDeviceId = React.useCallback((deviceId: string) => {\n    setSettings((prev) => ({ ...prev, videoDeviceId: deviceId }));\n  }, []);\n  const saveUsername = React.useCallback((username: string) => {\n    setSettings((prev) => ({ ...prev, username: username }));\n  }, []);\n\n  React.useEffect(() => {\n    saveUserChoices(userChoices, options.preventSave ?? false);\n  }, [userChoices, options.preventSave]);\n\n  return {\n    userChoices,\n    saveAudioInputEnabled,\n    saveVideoInputEnabled,\n    saveAudioInputDeviceId,\n    saveVideoInputDeviceId,\n    saveUsername,\n  };\n}\n","import * as React from 'react';\nimport { LocalParticipant } from 'livekit-client';\nimport type { Participant, Room } from 'livekit-client';\nimport { encryptionStatusObservable } from '@livekit/components-core';\nimport { useEnsureParticipant, useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * @alpha\n */\nexport interface UseIsEncryptedOptions {\n  room?: Room;\n}\n\n/**\n * @alpha\n */\nexport function useIsEncrypted(participant?: Participant, options: UseIsEncryptedOptions = {}) {\n  const p = useEnsureParticipant(participant);\n\n  const room = useEnsureRoom(options.room);\n\n  const observer = React.useMemo(() => encryptionStatusObservable(room, p), [room, p]);\n  const isEncrypted = useObservableState(\n    observer,\n    p.isLocal ? (p as LocalParticipant).isE2EEEnabled : !!p?.isEncrypted,\n  );\n  return isEncrypted;\n}\n","import * as React from 'react';\nimport type { LocalAudioTrack, RemoteAudioTrack, AudioAnalyserOptions } from 'livekit-client';\nimport { Track, createAudioAnalyser } from 'livekit-client';\nimport {\n  type TrackReference,\n  isTrackReference,\n  type TrackReferenceOrPlaceholder,\n} from '@livekit/components-core';\n\n/**\n * @alpha\n * Hook for tracking the volume of an audio track using the Web Audio API.\n */\nexport function useTrackVolume(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReference,\n  options: AudioAnalyserOptions = { fftSize: 32, smoothingTimeConstant: 0 },\n) {\n  const track = isTrackReference(trackOrTrackReference)\n    ? <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference.publication.track\n    : trackOrTrackReference;\n  const [volume, setVolume] = React.useState(0);\n  React.useEffect(() => {\n    if (!track || !track.mediaStream) {\n      return;\n    }\n\n    const { cleanup, analyser } = createAudioAnalyser(track, options);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getByteFrequencyData(dataArray);\n      let sum = 0;\n      for (let i = 0; i < dataArray.length; i++) {\n        const a = dataArray[i];\n        sum += a * a;\n      }\n      setVolume(Math.sqrt(sum / dataArray.length) / 255);\n    };\n\n    const interval = setInterval(updateVolume, 1000 / 30);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return volume;\n}\n\nconst normalizeFrequencies = (frequencies: Float32Array) => {\n  const normalizeDb = (value: number) => {\n    const minDb = -100;\n    const maxDb = -10;\n    let db = 1 - (Math.max(minDb, Math.min(maxDb, value)) * -1) / 100;\n    db = Math.sqrt(db);\n\n    return db;\n  };\n\n  // Normalize all frequency values\n  return frequencies.map((value) => {\n    if (value === -Infinity) {\n      return 0;\n    }\n    return normalizeDb(value);\n  });\n};\n\n/**\n * Interface for configuring options for the useMultibandTrackVolume hook.\n * @alpha\n */\nexport interface MultiBandTrackVolumeOptions {\n  bands?: number;\n  /**\n   * cut off of frequency bins on the lower end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  loPass?: number;\n  /**\n   * cut off of frequency bins on the higher end\n   * Note: this is not a frequency measure, but in relation to analyserOptions.fftSize,\n   */\n  hiPass?: number;\n  /**\n   * update should run every x ms\n   */\n  updateInterval?: number;\n  analyserOptions?: AnalyserOptions;\n}\n\nconst multibandDefaults = {\n  bands: 5,\n  loPass: 100,\n  hiPass: 600,\n  updateInterval: 32,\n  analyserOptions: { fftSize: 2048 },\n} as const satisfies MultiBandTrackVolumeOptions;\n\n/**\n * Hook for tracking the volume of an audio track across multiple frequency bands using the Web Audio API.\n * @alpha\n */\nexport function useMultibandTrackVolume(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: MultiBandTrackVolumeOptions = {},\n) {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const opts = { ...multibandDefaults, ...options };\n  const [frequencyBands, setFrequencyBands] = React.useState<Array<number>>(\n    new Array(opts.bands).fill(0),\n  );\n\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, opts.analyserOptions);\n\n    const bufferLength = analyser.frequencyBinCount;\n    const dataArray = new Float32Array(bufferLength);\n\n    const updateVolume = () => {\n      analyser.getFloatFrequencyData(dataArray);\n      let frequencies: Float32Array = new Float32Array(dataArray.length);\n      for (let i = 0; i < dataArray.length; i++) {\n        frequencies[i] = dataArray[i];\n      }\n      frequencies = frequencies.slice(options.loPass, options.hiPass);\n\n      const normalizedFrequencies = normalizeFrequencies(frequencies); // is this needed ?\n      const chunkSize = Math.ceil(normalizedFrequencies.length / opts.bands); // we want logarithmic chunking here\n      const chunks: Array<number> = [];\n      for (let i = 0; i < opts.bands; i++) {\n        const summedVolumes = normalizedFrequencies\n          .slice(i * chunkSize, (i + 1) * chunkSize)\n          .reduce((acc, val) => (acc += val), 0);\n        chunks.push(summedVolumes / chunkSize);\n      }\n\n      setFrequencyBands(chunks);\n    };\n\n    const interval = setInterval(updateVolume, opts.updateInterval);\n\n    return () => {\n      cleanup();\n      clearInterval(interval);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options)]);\n\n  return frequencyBands;\n}\n\n/**\n * @alpha\n */\nexport interface AudioWaveformOptions {\n  barCount?: number;\n  volMultiplier?: number;\n  updateInterval?: number;\n}\n\nconst waveformDefaults = {\n  barCount: 120,\n  volMultiplier: 5,\n  updateInterval: 20,\n} as const satisfies AudioWaveformOptions;\n\n/**\n * @alpha\n */\nexport function useAudioWaveform(\n  trackOrTrackReference?: LocalAudioTrack | RemoteAudioTrack | TrackReferenceOrPlaceholder,\n  options: AudioWaveformOptions = {},\n) {\n  const track =\n    trackOrTrackReference instanceof Track\n      ? trackOrTrackReference\n      : <LocalAudioTrack | RemoteAudioTrack | undefined>trackOrTrackReference?.publication?.track;\n  const opts = { ...waveformDefaults, ...options };\n\n  const aggregateWave = React.useRef(new Float32Array());\n  const timeRef = React.useRef(performance.now());\n  const updates = React.useRef(0);\n  const [bars, setBars] = React.useState<number[]>([]);\n\n  const onUpdate = React.useCallback((wave: Float32Array) => {\n    setBars(\n      Array.from(\n        filterData(wave, opts.barCount).map((v) => Math.sqrt(v) * opts.volMultiplier),\n        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),\n      ),\n    );\n  }, []);\n\n  React.useEffect(() => {\n    if (!track || !track?.mediaStream) {\n      return;\n    }\n    const { analyser, cleanup } = createAudioAnalyser(track, {\n      fftSize: getFFTSizeValue(opts.barCount),\n    });\n\n    const bufferLength = getFFTSizeValue(opts.barCount);\n    const dataArray = new Float32Array(bufferLength);\n\n    const update = () => {\n      updateWaveform = requestAnimationFrame(update);\n      analyser.getFloatTimeDomainData(dataArray);\n      aggregateWave.current.map((v, i) => v + dataArray[i]);\n      updates.current += 1;\n\n      if (performance.now() - timeRef.current >= opts.updateInterval) {\n        const newData = dataArray.map((v) => v / updates.current);\n        onUpdate(newData);\n        timeRef.current = performance.now();\n        updates.current = 0;\n      }\n    };\n\n    let updateWaveform = requestAnimationFrame(update);\n\n    return () => {\n      cleanup();\n      cancelAnimationFrame(updateWaveform);\n    };\n  }, [track, track?.mediaStream, JSON.stringify(options), onUpdate]);\n\n  return {\n    bars,\n  };\n}\n\nfunction getFFTSizeValue(x: number) {\n  if (x < 32) return 32;\n  else return pow2ceil(x);\n}\n\n// function sigmoid(x: number, k = 2, s = 0) {\n//   return 1 / (1 + Math.exp(-(x - s) / k));\n// }\n\nfunction pow2ceil(v: number) {\n  let p = 2;\n  while ((v >>= 1)) {\n    p <<= 1;\n  }\n  return p;\n}\n\nfunction filterData(audioData: Float32Array, numSamples: number) {\n  const blockSize = Math.floor(audioData.length / numSamples); // the number of samples in each subdivision\n  const filteredData = new Float32Array(numSamples);\n  for (let i = 0; i < numSamples; i++) {\n    const blockStart = blockSize * i; // the location of the first sample in the block\n    let sum = 0;\n    for (let j = 0; j < blockSize; j++) {\n      sum = sum + Math.abs(audioData[blockStart + j]); // find the sum of all the samples in the block\n    }\n    filteredData[i] = sum / blockSize; // divide the sum by the block size to get the average\n  }\n  return filteredData;\n}\n\n// function normalizeData(audioData: Float32Array) {\n//   const multiplier = Math.pow(Math.max(...audioData), -1);\n//   return audioData.map((n) => n * multiplier);\n// }\n","import * as React from 'react';\nimport type { TrackReference } from '@livekit/components-core';\nimport { participantTracksObservable } from '@livekit/components-core';\nimport { useObservableState } from './internal';\nimport type { Track } from 'livekit-client';\nimport { useMaybeParticipantContext } from '../context';\nimport { useRemoteParticipants } from './useRemoteParticipants';\n\n/**\n * `useParticipantTracks` is a custom React that allows you to get tracks of a specific participant only, by specifiying the participant's identity.\n * If the participant identity is not passed the hook will try to get the participant from a participant context.\n * @public\n */\nexport function useParticipantTracks(\n  sources: Track.Source[],\n  participantIdentity?: string,\n): TrackReference[] {\n  const participantContext = useMaybeParticipantContext();\n  const remoteParticipants = useRemoteParticipants({ updateOnlyOn: [] });\n\n  const p = React.useMemo(() => {\n    if (participantIdentity) {\n      return remoteParticipants.find((p) => p.identity === participantIdentity);\n    }\n    return participantContext;\n  }, [participantIdentity, remoteParticipants, participantContext]);\n\n  const observable = React.useMemo(() => {\n    if (!p) {\n      return undefined;\n    }\n    return participantTracksObservable(p, { sources });\n  }, [p, JSON.stringify(sources)]);\n\n  const trackRefs = useObservableState(observable, [] as TrackReference[]);\n\n  return trackRefs;\n}\n","import * as React from 'react';\nimport { type TrackReferenceOrPlaceholder, trackSyncTimeObserver } from '@livekit/components-core';\nimport { useObservableState } from './internal';\n\n/**\n * @internal\n */\nexport function useTrackSyncTime(ref: TrackReferenceOrPlaceholder | undefined) {\n  const observable = React.useMemo(\n    () => (ref?.publication?.track ? trackSyncTimeObserver(ref?.publication.track) : undefined),\n    [ref?.publication?.track],\n  );\n  return useObservableState(observable, {\n    timestamp: Date.now(),\n    rtpTimestamp: ref?.publication?.track?.rtpTimestamp,\n  });\n}\n","import {\n  type ReceivedTranscriptionSegment,\n  addMediaTimestampToTranscription as addTimestampsToTranscription,\n  dedupeSegments,\n  // getActiveTranscriptionSegments,\n  getTrackReferenceId,\n  trackTranscriptionObserver,\n  type TrackReferenceOrPlaceholder,\n  // didActiveSegmentsChange,\n} from '@livekit/components-core';\nimport type { TranscriptionSegment } from 'livekit-client';\nimport * as React from 'react';\nimport { useTrackSyncTime } from './useTrackSyncTime';\n\n/**\n * @alpha\n */\nexport interface TrackTranscriptionOptions {\n  /**\n   * how many transcription segments should be buffered in state\n   * @defaultValue 100\n   */\n  bufferSize?: number;\n  /**\n   * optional callback for retrieving newly incoming transcriptions only\n   */\n  onTranscription?: (newSegments: TranscriptionSegment[]) => void;\n  /** amount of time (in ms) that the segment is considered `active` past its original segment duration, defaults to 2_000 */\n  // maxAge?: number;\n}\n\nconst TRACK_TRANSCRIPTION_DEFAULTS = {\n  bufferSize: 100,\n  // maxAge: 2_000,\n} as const satisfies TrackTranscriptionOptions;\n\n/**\n * @returns An object consisting of `segments` with maximum length of opts.bufferSize\n * @alpha\n */\nexport function useTrackTranscription(\n  trackRef: TrackReferenceOrPlaceholder | undefined,\n  options?: TrackTranscriptionOptions,\n) {\n  const opts = { ...TRACK_TRANSCRIPTION_DEFAULTS, ...options };\n  const [segments, setSegments] = React.useState<Array<ReceivedTranscriptionSegment>>([]);\n\n  const syncTimestamps = useTrackSyncTime(trackRef);\n  const handleSegmentMessage = (newSegments: TranscriptionSegment[]) => {\n    opts.onTranscription?.(newSegments);\n    setSegments((prevSegments) =>\n      dedupeSegments(\n        prevSegments,\n        // when first receiving a segment, add the current media timestamp to it\n        newSegments.map((s) => addTimestampsToTranscription(s, syncTimestamps)),\n        opts.bufferSize,\n      ),\n    );\n  };\n  React.useEffect(() => {\n    if (!trackRef?.publication) {\n      return;\n    }\n    const subscription = trackTranscriptionObserver(trackRef.publication).subscribe((evt) => {\n      handleSegmentMessage(...evt);\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [trackRef && getTrackReferenceId(trackRef), handleSegmentMessage]);\n\n  return { segments };\n}\n","import { participantAttributesObserver } from '@livekit/components-core';\nimport type { Participant } from 'livekit-client';\nimport * as React from 'react';\nimport { useEnsureParticipant, useMaybeParticipantContext } from '../context';\nimport { useObservableState } from './internal';\n\n/**\n * The `useParticipantAttributes` hook returns the attributes of a given participant and allows to set them.\n * It requires a `Participant` object passed as property or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const { attributes } = useParticipantAttributes({ participant });\n * ```\n * @public\n */\nexport interface UseParticipantAttributesOptions {\n  participant?: Participant;\n}\n\n/** @public */\nexport function useParticipantAttributes(props: UseParticipantAttributesOptions = {}) {\n  const participantContext = useMaybeParticipantContext();\n  const p = props.participant ?? participantContext;\n  const attributeObserver = React.useMemo(\n    // weird typescript constraint\n    () => (p ? participantAttributesObserver(p) : participantAttributesObserver(p)),\n    [p],\n  );\n  const attributeState = useObservableState(attributeObserver, {\n    attributes: p?.attributes,\n  });\n\n  return attributeState;\n}\n\n/**\n * The `useParticipantAttribute` hook returns the latest value of a given attribute key of a participant.\n * It requires a `Participant` object passed as property in the `UseParticipantAttributesOptions` or via the `ParticipantContext`.\n *\n * @example\n * ```tsx\n * const myAttributeValue = useParticipantAttribute('targetAttributeName');\n * ```\n * @public\n */\nexport function useParticipantAttribute(\n  attributeKey: string,\n  options: UseParticipantAttributesOptions = {},\n) {\n  const p = useEnsureParticipant(options.participant);\n  const [attribute, setAttribute] = React.useState(p.attributes[attributeKey]);\n\n  React.useEffect(() => {\n    if (!p) {\n      return;\n    }\n    const subscription = participantAttributesObserver(p).subscribe((val) => {\n      if (val.changed[attributeKey] !== undefined) {\n        setAttribute(val.attributes[attributeKey]);\n      }\n    });\n    return () => {\n      subscription.unsubscribe();\n    };\n  }, [p, attributeKey]);\n\n  return attribute;\n}\n","import * as React from 'react';\nimport { ConnectionState, ParticipantKind, Track } from 'livekit-client';\nimport type { RemoteParticipant } from 'livekit-client';\nimport type { ReceivedTranscriptionSegment, TrackReference } from '@livekit/components-core';\nimport { useRemoteParticipants } from './useRemoteParticipants';\nimport { useParticipantTracks } from './useParticipantTracks';\nimport { useTrackTranscription } from './useTrackTranscription';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useParticipantAttributes } from './useParticipantAttributes';\n\n/**\n * @beta\n */\nexport type AgentState =\n  | 'disconnected'\n  | 'connecting'\n  | 'initializing'\n  | 'listening'\n  | 'thinking'\n  | 'speaking';\n\n/**\n * @beta\n */\nexport interface VoiceAssistant {\n  /**\n   * The agent participant.\n   */\n  agent: RemoteParticipant | undefined;\n  /**\n   * The current state of the agent.\n   */\n  state: AgentState;\n  /**\n   * The microphone track published by the agent or associated avatar worker (if any).\n   */\n  audioTrack: TrackReference | undefined;\n  /**\n   * The camera track published by the agent or associated avatar worker (if any).\n   */\n  videoTrack: TrackReference | undefined;\n  /**\n   * The transcriptions of the agent's microphone track (if any).\n   */\n  agentTranscriptions: ReceivedTranscriptionSegment[];\n  /**\n   * The agent's participant attributes.\n   */\n  agentAttributes: RemoteParticipant['attributes'] | undefined;\n}\n\nconst state_attribute = 'lk.agent.state';\n\n/**\n * This hook looks for the first agent-participant in the room.\n * @remarks This hook requires an agent running with livekit-agents \\>= 0.9.0\n * @example\n * ```tsx\n * const { state, audioTrack, agentTranscriptions, agentAttributes } = useVoiceAssistant();\n * ```\n * @beta\n */\nexport function useVoiceAssistant(): VoiceAssistant {\n  const remoteParticipants = useRemoteParticipants();\n  const agent = remoteParticipants.find(\n    (p) => p.kind === ParticipantKind.AGENT && !('lk.publish_on_behalf' in p.attributes),\n  );\n  const worker = remoteParticipants.find(\n    (p) =>\n      p.kind === ParticipantKind.AGENT && p.attributes['lk.publish_on_behalf'] === agent?.identity,\n  );\n  const agentTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    agent?.identity,\n  );\n  const workerTracks = useParticipantTracks(\n    [Track.Source.Microphone, Track.Source.Camera],\n    worker?.identity,\n  );\n  const audioTrack =\n    agentTracks.find((t) => t.source === Track.Source.Microphone) ??\n    workerTracks.find((t) => t.source === Track.Source.Microphone);\n  const videoTrack =\n    agentTracks.find((t) => t.source === Track.Source.Camera) ??\n    workerTracks.find((t) => t.source === Track.Source.Camera);\n  const { segments: agentTranscriptions } = useTrackTranscription(audioTrack);\n  const connectionState = useConnectionState();\n  const { attributes } = useParticipantAttributes({ participant: agent });\n\n  const state: AgentState = React.useMemo(() => {\n    if (connectionState === ConnectionState.Disconnected) {\n      return 'disconnected';\n    } else if (\n      connectionState === ConnectionState.Connecting ||\n      !agent ||\n      !attributes?.[state_attribute]\n    ) {\n      return 'connecting';\n    } else {\n      return attributes[state_attribute] as AgentState;\n    }\n  }, [attributes, agent, connectionState]);\n\n  return {\n    agent,\n    state,\n    audioTrack,\n    videoTrack,\n    agentTranscriptions,\n    agentAttributes: attributes,\n  };\n}\n","import { recordingStatusObservable } from '@livekit/components-core';\nimport * as React from 'react';\nimport { useEnsureRoom } from '../context';\nimport { useObservableState } from './internal';\nimport { useConnectionState } from './useConnectionStatus';\nimport type { Room } from 'livekit-client';\n\n/**\n * The `useIsRecording` hook returns a `boolean` that indicates if the room is currently being recorded.\n * @example\n * ```tsx\n * const isRecording = useIsRecording();\n * ```\n * @public\n */\nexport function useIsRecording(room?: Room) {\n  const r = useEnsureRoom(room);\n  const connectionState = useConnectionState(r);\n  const observable = React.useMemo(() => recordingStatusObservable(r), [r, connectionState]);\n  const isRecording = useObservableState(observable, r.isRecording);\n\n  return isRecording;\n}\n","import * as React from 'react';\nimport { ConnectionState } from 'livekit-client';\nimport { setupTextStream, type TextStreamData } from '@livekit/components-core';\nimport { useRoomContext } from '../context';\nimport { useConnectionState } from './useConnectionStatus';\nimport { useObservableState } from './internal';\n\n/**\n * @beta\n * @param topic - the topic to listen to\n * @returns an array of TextStreamData that holds the text, participantInfo, and streamInfo\n * @example\n * ```tsx\n * const { textStreams } = useTextStream('my-topic');\n * return <div>{textStreams.map((textStream) => textStream.text)}</div>;\n * ```\n */\nexport function useTextStream(topic: string) {\n  const room = useRoomContext();\n\n  const connectionState = useConnectionState(room);\n  const isDisconnected = connectionState === ConnectionState.Disconnected;\n\n  const textStreamData = React.useMemo(() => setupTextStream(room, topic), [room, topic]);\n  const textStreamObservable = isDisconnected ? undefined : textStreamData;\n\n  const textStreams = useObservableState<TextStreamData[]>(textStreamObservable, []);\n\n  return { textStreams };\n}\n","import * as React from 'react';\nimport { useTextStream } from './useTextStream';\nimport { DataTopic } from '@livekit/components-core';\n\n/**\n * @beta\n */\nexport interface UseTranscriptionsOptions {\n  participantIdentities?: string[];\n  trackSids?: string[];\n}\n\n/**\n * @beta\n * useTranscriptions is a hook that returns the transcriptions for the given participant identities and track sids,\n * if no options are provided, it will return all transcriptions\n * @example\n * ```tsx\n * const transcriptions = useTranscriptions();\n * return <div>{transcriptions.map((transcription) => transcription.text)}</div>;\n * ```\n */\nexport function useTranscriptions(opts?: UseTranscriptionsOptions) {\n  const { participantIdentities, trackSids } = opts ?? {};\n  const { textStreams } = useTextStream(DataTopic.TRANSCRIPTION);\n\n  const filteredMessages = React.useMemo(\n    () =>\n      textStreams\n        .filter((stream) =>\n          participantIdentities\n            ? participantIdentities.includes(stream.participantInfo.identity)\n            : true,\n        )\n        .filter((stream) =>\n          trackSids\n            ? trackSids.includes(stream.streamInfo.attributes?.['lk.transcribed_track_id'] ?? '')\n            : true,\n        ),\n    [textStreams, participantIdentities, trackSids],\n  );\n\n  return filteredMessages;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}