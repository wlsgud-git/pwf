import * as r from "react";
import { u as k, r as j, a as W, b as X, c as w, d as Y, e as Z, f as A, g as K, h as ee, i as R, j as te, k as ne, m as se, G as ae, n as re, o as ce, p as N, q as oe, t as ie, v as G, w as Q, x as $, y as ue, l as E, z as de, A as le, B as F, C as fe, D as pe, E as be, F as me, H as Se, I as ge, J as ve, K as he, M as z, N as Me, O as ye, P as Pe, Q as ke, S as Te, T as Ee, U as we, V as Ae, W as H, X as Ce, Y as Oe, Z as Ie, _ as De, $ as Le, a0 as Re, a1 as Ne, a2 as Fe, a3 as Ve, a4 as _e, a5 as ze, a6 as Be, a7 as L, a8 as qe, a9 as Ue, aa as Je } from "./contexts-BPNgUYT_.mjs";
import { m as T } from "./room-CDUkJ6U1.mjs";
import { ConnectionState as C, LocalTrackPublication as xe, facingModeFromLocalTrack as We, Room as Ge, Track as v, createAudioAnalyser as V, ParticipantKind as B } from "livekit-client";
const Qe = (e) => {
  const t = r.useRef(e);
  return r.useEffect(() => {
    t.current = e;
  }), t;
};
function $e(e, t) {
  const n = je(), s = Qe(t);
  return r.useLayoutEffect(() => {
    let a = !1;
    const c = e.current;
    if (!c) return;
    function o(u, i) {
      a || s.current(u, i);
    }
    return n == null || n.subscribe(c, o), () => {
      a = !0, n == null || n.unsubscribe(c, o);
    };
  }, [e.current, n, s]), n == null ? void 0 : n.observer;
}
function He() {
  let e = !1, t = [];
  const n = /* @__PURE__ */ new Map();
  if (typeof window > "u")
    return;
  const s = new ResizeObserver((a, c) => {
    t = t.concat(a), e || window.requestAnimationFrame(() => {
      const o = /* @__PURE__ */ new Set();
      for (let u = 0; u < t.length; u++) {
        if (o.has(t[u].target)) continue;
        o.add(t[u].target);
        const i = n.get(t[u].target);
        i == null || i.forEach((d) => d(t[u], c));
      }
      t = [], e = !1;
    }), e = !0;
  });
  return {
    observer: s,
    subscribe(a, c) {
      s.observe(a);
      const o = n.get(a) ?? [];
      o.push(c), n.set(a, o);
    },
    unsubscribe(a, c) {
      const o = n.get(a) ?? [];
      if (o.length === 1) {
        s.unobserve(a), n.delete(a);
        return;
      }
      const u = o.indexOf(c);
      u !== -1 && o.splice(u, 1), n.set(a, o);
    }
  };
}
let D;
const je = () => D || (D = He()), Xe = (e) => {
  const [t, n] = r.useState({ width: 0, height: 0 });
  r.useLayoutEffect(() => {
    if (e.current) {
      const { width: a, height: c } = e.current.getBoundingClientRect();
      n({ width: a, height: c });
    }
  }, [e.current]);
  const s = r.useCallback(
    (a) => n(a.contentRect),
    []
  );
  return $e(e, s), t;
};
function b(e, t, n = !0) {
  const [s, a] = r.useState(t);
  return r.useEffect(() => {
    if (n && a(t), typeof window > "u" || !e) return;
    const c = e.subscribe(a);
    return () => c.unsubscribe();
  }, [e, n]), s;
}
function vt(e) {
  const t = (c) => typeof window < "u" ? window.matchMedia(c).matches : !1, [n, s] = r.useState(t(e));
  function a() {
    s(t(e));
  }
  return r.useEffect(() => {
    const c = window.matchMedia(e);
    return a(), c.addListener ? c.addListener(a) : c.addEventListener("change", a), () => {
      c.removeListener ? c.removeListener(a) : c.removeEventListener("change", a);
    };
  }, [e]), n;
}
function ht(e) {
  const t = k(e), n = r.useCallback(async () => {
    await t.startAudio();
  }, [t]), s = r.useMemo(
    () => j(t),
    [t]
  ), { canPlayAudio: a } = b(s, {
    canPlayAudio: t.canPlaybackAudio
  });
  return { canPlayAudio: a, startAudio: n };
}
function Mt(e) {
  const { state: t, dispatch: n } = W().pin;
  return { buttonProps: r.useMemo(() => {
    const { className: a } = X();
    return T(e, {
      className: a,
      disabled: !(t != null && t.length),
      onClick: () => {
        n && n({ msg: "clear_pin" });
      }
    });
  }, [e, n, t]) };
}
function yt(e = {}) {
  const t = w(e.participant), { className: n, connectionQualityObserver: s } = r.useMemo(
    () => Y(t),
    [t]
  ), a = b(s, t.connectionQuality);
  return { className: n, quality: a };
}
function O(e) {
  const t = k(e), n = r.useMemo(() => Z(t), [t]);
  return b(n, t.state);
}
function Pt(e, t) {
  const n = typeof e == "function" ? e : t, s = typeof e == "string" ? e : void 0, a = A(), { send: c, messageObservable: o, isSendingObservable: u } = r.useMemo(
    () => K(a, s, n),
    [a, s, n]
  ), i = b(o, void 0), d = b(u, !1);
  return {
    message: i,
    send: c,
    isSending: d
  };
}
function kt(e) {
  const t = A(), n = O(t);
  return { buttonProps: r.useMemo(() => {
    const { className: a, disconnect: c } = ee(t);
    return T(e, {
      className: a,
      onClick: () => c(e.stopTracks ?? !0),
      disabled: n === C.Disconnected
    });
  }, [t, e, n]) };
}
function Ye(e) {
  if (e.publication instanceof xe) {
    const t = e.publication.track;
    if (t) {
      const { facingMode: n } = We(t);
      return n;
    }
  }
  return "undefined";
}
function Tt({ trackRef: e, props: t }) {
  const n = R(e), s = te(), { className: a } = r.useMemo(() => ne(), []), c = r.useMemo(() => se(n, s == null ? void 0 : s.pin.state), [n, s == null ? void 0 : s.pin.state]);
  return { mergedProps: r.useMemo(
    () => T(t, {
      className: a,
      onClick: (u) => {
        var i, d, f, l, p;
        (i = t.onClick) == null || i.call(t, u), c ? (f = s == null ? void 0 : (d = s.pin).dispatch) == null || f.call(d, {
          msg: "clear_pin"
        }) : (p = s == null ? void 0 : (l = s.pin).dispatch) == null || p.call(l, {
          msg: "set_pin",
          trackReference: n
        });
      }
    }),
    [t, a, n, c, s == null ? void 0 : s.pin]
  ), inFocus: c };
}
function Et(e, t, n = {}) {
  const s = n.gridLayouts ?? ae, { width: a, height: c } = Xe(e), o = re(s, t, a, c);
  return r.useEffect(() => {
    e.current && o && (e.current.style.setProperty("--lk-col-count", o == null ? void 0 : o.columns.toString()), e.current.style.setProperty("--lk-row-count", o == null ? void 0 : o.rows.toString()));
  }, [e, o]), {
    layout: o,
    containerWidth: a,
    containerHeight: c
  };
}
function q(e, t = {}) {
  var u, i;
  const n = typeof e == "string" ? t.participant : e.participant, s = w(n), a = typeof e == "string" ? { participant: s, source: e } : e, [c, o] = r.useState(
    !!((u = a.publication) != null && u.isMuted || (i = s.getTrackPublication(a.source)) != null && i.isMuted)
  );
  return r.useEffect(() => {
    const d = ce(a).subscribe(o);
    return () => d.unsubscribe();
  }, [N(a)]), c;
}
function Ze(e) {
  const t = w(e), n = r.useMemo(() => oe(t), [t]);
  return b(n, t.isSpeaking);
}
function Ke(e = {}) {
  const t = k(e.room), [n, s] = r.useState(t.localParticipant), [a, c] = r.useState(
    n.isMicrophoneEnabled
  ), [o, u] = r.useState(n.isCameraEnabled), [i, d] = r.useState(
    n.isScreenShareEnabled
  ), [f, l] = r.useState(
    n.lastMicrophoneError
  ), [p, S] = r.useState(n.lastCameraError), [g, m] = r.useState(
    void 0
  ), [y, h] = r.useState(void 0), P = (M) => {
    u(M.isCameraEnabled), c(M.isMicrophoneEnabled), d(M.isScreenShareEnabled), h(M.cameraTrack), m(M.microphoneTrack), l(M.participant.lastMicrophoneError), S(M.participant.lastCameraError), s(M.participant);
  };
  return r.useEffect(() => {
    const M = ie(t.localParticipant).subscribe(P);
    return () => M.unsubscribe();
  }, [t]), {
    isMicrophoneEnabled: a,
    isScreenShareEnabled: i,
    isCameraEnabled: o,
    microphoneTrack: g,
    cameraTrack: y,
    lastMicrophoneError: f,
    lastCameraError: p,
    localParticipant: n
  };
}
function wt() {
  const e = A(), t = r.useMemo(
    () => G(e.localParticipant),
    [e]
  );
  return b(t, e.localParticipant.permissions);
}
function At({
  kind: e,
  room: t,
  track: n,
  requestPermissions: s,
  onError: a
}) {
  const c = Q(), o = r.useMemo(() => t ?? c ?? new Ge(), [t, c]), u = r.useMemo(
    () => $(e, a, s),
    [e, s, a]
  ), i = b(u, []), [d, f] = r.useState(
    (o == null ? void 0 : o.getActiveDevice(e)) ?? "default"
  ), { className: l, activeDeviceObservable: p, setActiveMediaDevice: S } = r.useMemo(
    () => ue(e, o),
    [e, o, n]
  );
  return r.useEffect(() => {
    const g = p.subscribe((m) => {
      m && (E.info("setCurrentDeviceId", m), f(m));
    });
    return () => {
      g == null || g.unsubscribe();
    };
  }, [p]), { devices: i, className: l, activeDeviceId: d, setActiveMediaDevice: S };
}
function Ct({
  kind: e,
  onError: t
}) {
  const n = r.useMemo(
    () => $(e, t),
    [e, t]
  );
  return b(n, []);
}
function et(e, t, n = {}) {
  const s = r.useRef([]), a = r.useRef(-1), c = t !== a.current, o = typeof n.customSortFunction == "function" ? n.customSortFunction(e) : de(e);
  let u = [...o];
  if (c === !1)
    try {
      u = le(s.current, o, t);
    } catch (i) {
      E.error("Error while running updatePages(): ", i);
    }
  return c ? s.current = o : s.current = u, a.current = t, u;
}
function Ot(e, t) {
  const [n, s] = r.useState(1), a = Math.max(Math.ceil(t.length / e), 1);
  n > a && s(a);
  const c = n * e, o = c - e, u = (l) => {
    s((p) => l === "next" ? p === a ? p : p + 1 : p === 1 ? p : p - 1);
  }, i = (l) => {
    l > a ? s(a) : l < 1 ? s(1) : s(l);
  }, f = et(t, e).slice(o, c);
  return {
    totalPageCount: a,
    nextPage: () => u("next"),
    prevPage: () => u("previous"),
    setPage: i,
    firstItemIndex: o,
    lastItemIndex: c,
    tracks: f,
    currentPage: n
  };
}
function It(e = {}) {
  let t = F();
  e.participant && (t = e.participant);
  const n = r.useMemo(() => fe(t), [t]), { identity: s, name: a, metadata: c } = b(n, {
    name: t == null ? void 0 : t.name,
    identity: t == null ? void 0 : t.identity,
    metadata: t == null ? void 0 : t.metadata
  });
  return { identity: s, name: a, metadata: c };
}
function Dt(e = {}) {
  const t = w(e.participant), n = r.useMemo(() => G(t), [t]);
  return b(n, t.permissions);
}
function Lt({
  trackRef: e,
  onParticipantClick: t,
  disableSpeakingIndicator: n,
  htmlProps: s
}) {
  const a = R(e), c = r.useMemo(() => {
    const { className: p } = pe();
    return T(s, {
      className: p,
      onClick: (S) => {
        var g;
        if ((g = s.onClick) == null || g.call(s, S), typeof t == "function") {
          const m = a.publication ?? a.participant.getTrackPublication(a.source);
          t({ participant: a.participant, track: m });
        }
      }
    });
  }, [
    s,
    t,
    a.publication,
    a.source,
    a.participant
  ]), o = a.participant.getTrackPublication(v.Source.Microphone), u = r.useMemo(() => ({
    participant: a.participant,
    source: v.Source.Microphone,
    publication: o
  }), [o, a.participant]), i = q(a), d = q(u), f = Ze(a.participant), l = Ye(a);
  return {
    elementProps: {
      "data-lk-audio-muted": d,
      "data-lk-video-muted": i,
      "data-lk-speaking": n === !0 ? !1 : f,
      "data-lk-local-participant": a.participant.isLocal,
      "data-lk-source": a.source,
      "data-lk-facing-mode": l,
      ...c
    }
  };
}
function _(e = {}) {
  const t = k(e.room), [n, s] = r.useState([]);
  return r.useEffect(() => {
    const a = be(t, {
      additionalRoomEvents: e.updateOnlyOn
    }).subscribe(s);
    return () => a.unsubscribe();
  }, [t, JSON.stringify(e.updateOnlyOn)]), n;
}
function Rt(e = {}) {
  const t = _(e), { localParticipant: n } = Ke(e);
  return r.useMemo(
    () => [n, ...t],
    [n, t]
  );
}
function Nt(e) {
  return e = me(e), r.useMemo(() => (e == null ? void 0 : e.pin.state) !== void 0 && e.pin.state.length >= 1 ? e.pin.state : [], [e.pin.state]);
}
function Ft(e, t = {}) {
  const n = A(), [s] = r.useState(t.updateOnlyOn), a = r.useMemo(() => typeof e == "string" ? Se(n, e, {
    additionalEvents: s
  }) : ge(n, e, {
    additionalEvents: s
  }), [n, JSON.stringify(e), s]), [c, o] = r.useState({
    p: void 0
  });
  return r.useEffect(() => {
    const u = a.subscribe((i) => o({ p: i }));
    return () => u.unsubscribe();
  }, [a]), c.p;
}
function Vt(e = {}) {
  const t = k(e.room), n = r.useMemo(() => ve(t), [t]), { name: s, metadata: a } = b(n, {
    name: t.name,
    metadata: t.metadata
  });
  return { name: s, metadata: a };
}
function tt() {
  const e = A(), t = r.useMemo(() => he(e), [e]);
  return b(t, e.activeSpeakers);
}
function _t(e) {
  const [t, n] = r.useState(
    z(e)
  ), s = tt();
  return r.useEffect(() => {
    n(z(e));
  }, [s, e]), t;
}
function zt({ room: e, props: t }) {
  const n = k(e), { className: s, roomAudioPlaybackAllowedObservable: a, handleStartAudioPlayback: c } = r.useMemo(
    () => Me(),
    []
  ), o = r.useMemo(
    () => a(n),
    [n, a]
  ), { canPlayAudio: u } = b(o, {
    canPlayAudio: n.canPlaybackAudio
  });
  return { mergedProps: r.useMemo(
    () => T(t, {
      className: s,
      onClick: () => {
        c(n);
      },
      style: { display: u ? "none" : "block" }
    }),
    [t, s, u, c, n]
  ), canPlayAudio: u };
}
function Bt({ room: e, props: t }) {
  const n = k(e), { className: s, roomVideoPlaybackAllowedObservable: a, handleStartVideoPlayback: c } = r.useMemo(
    () => ye(),
    []
  ), o = r.useMemo(
    () => a(n),
    [n, a]
  ), { canPlayVideo: u } = b(o, {
    canPlayVideo: n.canPlaybackVideo
  });
  return { mergedProps: r.useMemo(
    () => T(t, {
      className: s,
      onClick: () => {
        c(n);
      },
      style: { display: u ? "none" : "block" }
    }),
    [t, s, u, c, n]
  ), canPlayVideo: u };
}
function qt(e, t = {}) {
  const n = r.useRef(null), s = r.useRef(null), a = t.minSwipeDistance ?? 50, c = (i) => {
    s.current = null, n.current = i.targetTouches[0].clientX;
  }, o = (i) => {
    s.current = i.targetTouches[0].clientX;
  }, u = r.useCallback(() => {
    if (!n.current || !s.current)
      return;
    const i = n.current - s.current, d = i > a, f = i < -a;
    d && t.onLeftSwipe && t.onLeftSwipe(), f && t.onRightSwipe && t.onRightSwipe();
  }, [a, t]);
  r.useEffect(() => {
    const i = e.current;
    return i && (i.addEventListener("touchstart", c, { passive: !0 }), i.addEventListener("touchmove", o, { passive: !0 }), i.addEventListener("touchend", u, { passive: !0 })), () => {
      i && (i.removeEventListener("touchstart", c), i.removeEventListener("touchmove", o), i.removeEventListener("touchend", u));
    };
  }, [e, u]);
}
function Ut({ props: e }) {
  const { dispatch: t, state: n } = W().widget, { className: s } = r.useMemo(() => Pe(), []);
  return { mergedProps: r.useMemo(() => T(e, {
    className: s,
    onClick: () => {
      t && t({ msg: "toggle_chat" });
    },
    "aria-pressed": n != null && n.showChat ? "true" : "false",
    "data-lk-unread-msgs": n ? n.unreadMessages < 10 ? n.unreadMessages.toFixed(0) : "9+" : "0"
  }), [e, s, t, n]) };
}
function Jt(e, t, n = {}) {
  const [s, a] = r.useState(void 0);
  return r.useEffect(() => {
    var o;
    if (e === void 0)
      throw Error("token endpoint needs to be defined");
    if (((o = n.userInfo) == null ? void 0 : o.identity) === void 0)
      return;
    (async () => {
      E.debug("fetching token");
      const u = new URLSearchParams({ ...n.userInfo, roomName: t }), i = await fetch(`${e}?${u.toString()}`);
      if (!i.ok) {
        E.error(
          `Could not fetch token. Server responded with status ${i.status}: ${i.statusText}`
        );
        return;
      }
      const { accessToken: d } = await i.json();
      a(d);
    })();
  }, [e, t, JSON.stringify(n)]), s;
}
function xt(e) {
  var c, o;
  const t = R(e), { className: n, mediaMutedObserver: s } = r.useMemo(
    () => ke(t),
    [N(t)]
  );
  return { isMuted: b(
    s,
    !!((c = t.publication) != null && c.isMuted || (o = t.participant.getTrackPublication(t.source)) != null && o.isMuted)
  ), className: n };
}
function Wt({
  source: e,
  onChange: t,
  initialState: n,
  captureOptions: s,
  publishOptions: a,
  onDeviceError: c,
  ...o
}) {
  var P;
  const u = Q(), i = (P = u == null ? void 0 : u.localParticipant) == null ? void 0 : P.getTrackPublication(e), d = r.useRef(!1), { toggle: f, className: l, pendingObserver: p, enabledObserver: S } = r.useMemo(
    () => u ? Te(e, u, s, a, c) : Ee(),
    [u, e, JSON.stringify(s), a]
  ), g = b(p, !1), m = b(S, n ?? !!(i != null && i.isEnabled));
  r.useEffect(() => {
    t == null || t(m, d.current), d.current = !1;
  }, [m, t]), r.useEffect(() => {
    n !== void 0 && (E.debug("forcing initial toggle state", e, n), f(n));
  }, []);
  const y = r.useMemo(() => T(o, { className: l }), [o, l]), h = r.useCallback(
    (M) => {
      var I;
      d.current = !0, f().catch(() => d.current = !1), (I = o.onClick) == null || I.call(o, M);
    },
    [o, f]
  );
  return {
    toggle: f,
    enabled: m,
    pending: g,
    track: i,
    buttonProps: {
      ...y,
      "aria-pressed": m,
      "data-lk-source": e,
      "data-lk-enabled": m,
      disabled: g,
      onClick: h
    }
  };
}
function Gt(e = [
  v.Source.Camera,
  v.Source.Microphone,
  v.Source.ScreenShare,
  v.Source.ScreenShareAudio,
  v.Source.Unknown
], t = {}) {
  const n = k(t.room), [s, a] = r.useState([]), [c, o] = r.useState([]), u = r.useMemo(() => e.map((d) => we(d) ? d.source : d), [JSON.stringify(e)]);
  return r.useEffect(() => {
    const d = Ae(n, u, {
      additionalRoomEvents: t.updateOnlyOn,
      onlySubscribed: t.onlySubscribed
    }).subscribe(({ trackReferences: f, participants: l }) => {
      E.debug("setting track bundles", f, l), a(f), o(l);
    });
    return () => d.unsubscribe();
  }, [
    n,
    JSON.stringify(t.onlySubscribed),
    JSON.stringify(t.updateOnlyOn),
    JSON.stringify(e)
  ]), r.useMemo(() => {
    if (H(e)) {
      const d = st(e, c), f = Array.from(s);
      return c.forEach((l) => {
        d.has(l.identity) && (d.get(l.identity) ?? []).forEach((S) => {
          if (s.find(
            ({ participant: m, publication: y }) => l.identity === m.identity && y.source === S
          ))
            return;
          E.debug(
            `Add ${S} placeholder for participant ${l.identity}.`
          );
          const g = {
            participant: l,
            source: S
          };
          f.push(g);
        });
      }), f;
    } else
      return s;
  }, [s, c, e]);
}
function nt(e, t) {
  const n = new Set(e);
  for (const s of t)
    n.delete(s);
  return n;
}
function st(e, t) {
  const n = /* @__PURE__ */ new Map();
  if (H(e)) {
    const s = e.filter((a) => a.withPlaceholder).map((a) => a.source);
    t.forEach((a) => {
      const c = a.getTrackPublications().map((u) => {
        var i;
        return (i = u.track) == null ? void 0 : i.source;
      }).filter((u) => u !== void 0), o = Array.from(
        nt(new Set(s), new Set(c))
      );
      o.length > 0 && n.set(a.identity, o);
    });
  }
  return n;
}
function at(e) {
  const [t, n] = r.useState(Ce(e)), { trackObserver: s } = r.useMemo(() => Oe(e), [e.participant.sid ?? e.participant.identity, e.source]);
  return r.useEffect(() => {
    const a = s.subscribe((c) => {
      n(c);
    });
    return () => a == null ? void 0 : a.unsubscribe();
  }, [s]), {
    participant: e.participant,
    source: e.source ?? v.Source.Unknown,
    publication: t
  };
}
function Qt(e, t) {
  const n = w(t);
  return at({ name: e, participant: n });
}
function $t(e) {
  const t = A(), n = O(t), s = r.useMemo(
    () => n === C.Disconnected,
    [n]
  ), a = r.useMemo(
    () => Ie(t, e),
    [t, e, s]
  ), c = b(a.isSendingObservable, !1), o = b(a.messageObservable, []);
  return { send: a.send, chatMessages: o, isSending: c };
}
function Ht(e = {}) {
  const [t, n] = r.useState(
    De(e.defaults, e.preventLoad ?? !1)
  ), s = r.useCallback((i) => {
    n((d) => ({ ...d, audioEnabled: i }));
  }, []), a = r.useCallback((i) => {
    n((d) => ({ ...d, videoEnabled: i }));
  }, []), c = r.useCallback((i) => {
    n((d) => ({ ...d, audioDeviceId: i }));
  }, []), o = r.useCallback((i) => {
    n((d) => ({ ...d, videoDeviceId: i }));
  }, []), u = r.useCallback((i) => {
    n((d) => ({ ...d, username: i }));
  }, []);
  return r.useEffect(() => {
    Le(t, e.preventSave ?? !1);
  }, [t, e.preventSave]), {
    userChoices: t,
    saveAudioInputEnabled: s,
    saveVideoInputEnabled: a,
    saveAudioInputDeviceId: c,
    saveVideoInputDeviceId: o,
    saveUsername: u
  };
}
function jt(e, t = {}) {
  const n = w(e), s = k(t.room), a = r.useMemo(() => Re(s, n), [s, n]);
  return b(
    a,
    n.isLocal ? n.isE2EEEnabled : !!(n != null && n.isEncrypted)
  );
}
function Xt(e, t = { fftSize: 32, smoothingTimeConstant: 0 }) {
  const n = Ne(e) ? e.publication.track : e, [s, a] = r.useState(0);
  return r.useEffect(() => {
    if (!n || !n.mediaStream)
      return;
    const { cleanup: c, analyser: o } = V(n, t), u = o.frequencyBinCount, i = new Uint8Array(u), f = setInterval(() => {
      o.getByteFrequencyData(i);
      let l = 0;
      for (let p = 0; p < i.length; p++) {
        const S = i[p];
        l += S * S;
      }
      a(Math.sqrt(l / i.length) / 255);
    }, 1e3 / 30);
    return () => {
      c(), clearInterval(f);
    };
  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]), s;
}
const rt = (e) => {
  const t = (n) => {
    let c = 1 - Math.max(-100, Math.min(-10, n)) * -1 / 100;
    return c = Math.sqrt(c), c;
  };
  return e.map((n) => n === -1 / 0 ? 0 : t(n));
}, ct = {
  bands: 5,
  loPass: 100,
  hiPass: 600,
  updateInterval: 32,
  analyserOptions: { fftSize: 2048 }
};
function Yt(e, t = {}) {
  var o;
  const n = e instanceof v ? e : (o = e == null ? void 0 : e.publication) == null ? void 0 : o.track, s = { ...ct, ...t }, [a, c] = r.useState(
    new Array(s.bands).fill(0)
  );
  return r.useEffect(() => {
    if (!n || !(n != null && n.mediaStream))
      return;
    const { analyser: u, cleanup: i } = V(n, s.analyserOptions), d = u.frequencyBinCount, f = new Float32Array(d), p = setInterval(() => {
      u.getFloatFrequencyData(f);
      let S = new Float32Array(f.length);
      for (let h = 0; h < f.length; h++)
        S[h] = f[h];
      S = S.slice(t.loPass, t.hiPass);
      const g = rt(S), m = Math.ceil(g.length / s.bands), y = [];
      for (let h = 0; h < s.bands; h++) {
        const P = g.slice(h * m, (h + 1) * m).reduce((M, I) => M += I, 0);
        y.push(P / m);
      }
      c(y);
    }, s.updateInterval);
    return () => {
      i(), clearInterval(p);
    };
  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t)]), a;
}
const ot = {
  barCount: 120,
  volMultiplier: 5,
  updateInterval: 20
};
function Zt(e, t = {}) {
  var f;
  const n = e instanceof v ? e : (f = e == null ? void 0 : e.publication) == null ? void 0 : f.track, s = { ...ot, ...t }, a = r.useRef(new Float32Array()), c = r.useRef(performance.now()), o = r.useRef(0), [u, i] = r.useState([]), d = r.useCallback((l) => {
    i(
      Array.from(
        ut(l, s.barCount).map((p) => Math.sqrt(p) * s.volMultiplier)
        // wave.slice(0, opts.barCount).map((v) => sigmoid(v * opts.volMultiplier, 0.08, 0.2)),
      )
    );
  }, []);
  return r.useEffect(() => {
    if (!n || !(n != null && n.mediaStream))
      return;
    const { analyser: l, cleanup: p } = V(n, {
      fftSize: U(s.barCount)
    }), S = U(s.barCount), g = new Float32Array(S), m = () => {
      if (y = requestAnimationFrame(m), l.getFloatTimeDomainData(g), a.current.map((h, P) => h + g[P]), o.current += 1, performance.now() - c.current >= s.updateInterval) {
        const h = g.map((P) => P / o.current);
        d(h), c.current = performance.now(), o.current = 0;
      }
    };
    let y = requestAnimationFrame(m);
    return () => {
      p(), cancelAnimationFrame(y);
    };
  }, [n, n == null ? void 0 : n.mediaStream, JSON.stringify(t), d]), {
    bars: u
  };
}
function U(e) {
  return e < 32 ? 32 : it(e);
}
function it(e) {
  let t = 2;
  for (; e >>= 1; )
    t <<= 1;
  return t;
}
function ut(e, t) {
  const n = Math.floor(e.length / t), s = new Float32Array(t);
  for (let a = 0; a < t; a++) {
    const c = n * a;
    let o = 0;
    for (let u = 0; u < n; u++)
      o = o + Math.abs(e[c + u]);
    s[a] = o / n;
  }
  return s;
}
function J(e, t) {
  const n = F(), s = _({ updateOnlyOn: [] }), a = r.useMemo(() => t ? s.find((u) => u.identity === t) : n, [t, s, n]), c = r.useMemo(() => {
    if (a)
      return Fe(a, { sources: e });
  }, [a, JSON.stringify(e)]);
  return b(c, []);
}
function dt(e) {
  var n, s, a;
  const t = r.useMemo(
    () => {
      var c;
      return (c = e == null ? void 0 : e.publication) != null && c.track ? Ve(e == null ? void 0 : e.publication.track) : void 0;
    },
    [(n = e == null ? void 0 : e.publication) == null ? void 0 : n.track]
  );
  return b(t, {
    timestamp: Date.now(),
    rtpTimestamp: (a = (s = e == null ? void 0 : e.publication) == null ? void 0 : s.track) == null ? void 0 : a.rtpTimestamp
  });
}
const lt = {
  bufferSize: 100
  // maxAge: 2_000,
};
function ft(e, t) {
  const n = { ...lt, ...t }, [s, a] = r.useState([]), c = dt(e), o = (u) => {
    var i;
    (i = n.onTranscription) == null || i.call(n, u), a(
      (d) => ze(
        d,
        // when first receiving a segment, add the current media timestamp to it
        u.map((f) => Be(f, c)),
        n.bufferSize
      )
    );
  };
  return r.useEffect(() => {
    if (!(e != null && e.publication))
      return;
    const u = _e(e.publication).subscribe((i) => {
      o(...i);
    });
    return () => {
      u.unsubscribe();
    };
  }, [e && N(e), o]), { segments: s };
}
function pt(e = {}) {
  const t = F(), n = e.participant ?? t, s = r.useMemo(
    // weird typescript constraint
    () => n ? L(n) : L(n),
    [n]
  );
  return b(s, {
    attributes: n == null ? void 0 : n.attributes
  });
}
function Kt(e, t = {}) {
  const n = w(t.participant), [s, a] = r.useState(n.attributes[e]);
  return r.useEffect(() => {
    if (!n)
      return;
    const c = L(n).subscribe((o) => {
      o.changed[e] !== void 0 && a(o.attributes[e]);
    });
    return () => {
      c.unsubscribe();
    };
  }, [n, e]), s;
}
const x = "lk.agent.state";
function en() {
  const e = _(), t = e.find(
    (l) => l.kind === B.AGENT && !("lk.publish_on_behalf" in l.attributes)
  ), n = e.find(
    (l) => l.kind === B.AGENT && l.attributes["lk.publish_on_behalf"] === (t == null ? void 0 : t.identity)
  ), s = J(
    [v.Source.Microphone, v.Source.Camera],
    t == null ? void 0 : t.identity
  ), a = J(
    [v.Source.Microphone, v.Source.Camera],
    n == null ? void 0 : n.identity
  ), c = s.find((l) => l.source === v.Source.Microphone) ?? a.find((l) => l.source === v.Source.Microphone), o = s.find((l) => l.source === v.Source.Camera) ?? a.find((l) => l.source === v.Source.Camera), { segments: u } = ft(c), i = O(), { attributes: d } = pt({ participant: t }), f = r.useMemo(() => i === C.Disconnected ? "disconnected" : i === C.Connecting || !t || !(d != null && d[x]) ? "connecting" : d[x], [d, t, i]);
  return {
    agent: t,
    state: f,
    audioTrack: c,
    videoTrack: o,
    agentTranscriptions: u,
    agentAttributes: d
  };
}
function tn(e) {
  const t = k(e), n = O(t), s = r.useMemo(() => qe(t), [t, n]);
  return b(s, t.isRecording);
}
function bt(e) {
  const t = A(), s = O(t) === C.Disconnected, a = r.useMemo(() => Ue(t, e), [t, e]);
  return { textStreams: b(s ? void 0 : a, []) };
}
function nn(e) {
  const { participantIdentities: t, trackSids: n } = e ?? {}, { textStreams: s } = bt(Je.TRANSCRIPTION);
  return r.useMemo(
    () => s.filter(
      (c) => t ? t.includes(c.participantInfo.identity) : !0
    ).filter(
      (c) => {
        var o;
        return n ? n.includes(((o = c.streamInfo.attributes) == null ? void 0 : o["lk.transcribed_track_id"]) ?? "") : !0;
      }
    ),
    [s, t, n]
  );
}
export {
  wt as A,
  Nt as B,
  Ke as C,
  ht as D,
  Pt as E,
  Ye as F,
  q as G,
  Ze as H,
  It as I,
  Dt as J,
  Rt as K,
  Ft as L,
  _ as M,
  _t as N,
  tt as O,
  Jt as P,
  Qt as Q,
  Xt as R,
  Zt as S,
  J as T,
  ft as U,
  en as V,
  pt as W,
  Kt as X,
  tn as Y,
  bt as Z,
  nn as _,
  O as a,
  Ut as b,
  kt as c,
  Tt as d,
  At as e,
  zt as f,
  Bt as g,
  Wt as h,
  yt as i,
  b as j,
  xt as k,
  Lt as l,
  jt as m,
  Et as n,
  Ot as o,
  qt as p,
  Xe as q,
  et as r,
  Yt as s,
  Gt as t,
  Mt as u,
  Vt as v,
  $t as w,
  Ht as x,
  Ct as y,
  vt as z
};
//# sourceMappingURL=hooks-DnOXtSov.mjs.map
